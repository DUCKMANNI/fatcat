<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{shared/layout}">
<head>
<meta charset="utf-8">
<title>동물병원 검색</title>
<style>
/* CSS 스타일 */
#controls {
	background: rgba(255, 255, 255, 0.96);
	border: 1px solid #ddd;
	border-radius: 14px;
	padding: 10px 14px;
	display: flex;
	gap: 8px;
	align-items: center;
	margin: 20px auto;
	width: fit-content;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
	
}

#controls select {
	height: 36px;
	font-size: 20px;
	border-radius: 8px;
	border: 1px solid #ccc;
	margin: 5px auto;
	padding: 0 10px;
}
/* #controls button {
            cursor: pointer;
            border: none;
            background: #CD853F;
            color: #fff;
            font-weight: 600;
        } */
#mapListContainer {
	display: flex;
	width: calc(100% - 20px);
	height: 80vh;
	margin: 20px 15px 0;
	gap: 16px;
	box-sizing: border-box;
}

#map, #menu_wrap, #detailPanel {
	transition: all 0.3s ease;
}

#map {
	flex: 0.9;
	height: 100%;
	border: 1px solid #e5e5e5;
	border-radius: 24px;
	position: relative;
	box-shadow: 0 0 8px rgba(0, 0, 0, 0.12);
}

#menu_wrap {
	flex: 0.5;
	background: rgba(255, 255, 255, 0.96);
	border-radius: 24px;
	padding: 8px;
	font-size: 14px;
	overflow-y: auto;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
}

#menu_wrap h3 {
	margin: 6px 8px 10px;
	font-size: 16px;
}

#placesList {
	margin: 0;
	padding: 0 6px 8px;
}

#placesList li {
	list-style: none;
}

#placesList .item {
	display: flex;
	align-items: flex-start;
	padding: 10px;
	border-bottom: 1px solid #ddd;
	cursor: pointer;
}

#placesList .marker-number {
	width: 23px;
	height: 23px;
	display: flex;
	align-items: center;
	justify-content: center;
	background: #D2B48C;
	color: white;
	border-radius: 20px;
	font-size: 13px;
	font-weight: bold;
	margin-right: 10px;
	flex-shrink: 0;
}

#placesList .info {
	flex: 1;
}

#placesList .info h5 {
	margin: 0 0 4px;
	font-size: 20px;
	font-weight: bold;
}

#placesList .info p {
	margin: 2px 0;
	font-size: 18px;
	color: #555;
}

#pagination {
	text-align: center;
	padding: 6px 0 10px;
}

#pagination a {
	display: inline-block;
	margin: 0 6px;
	text-decoration: none;
	color: #666;
}

#pagination .on {
	font-weight: 700;
	color: #6C3C30;
	pointer-events: none;
}
/* .fixed-element button {
            display: block !important;
        } */
#detailPanel {
	flex: 0;
	width: 0;
	padding: 0;
	overflow-y: auto;
	background: #fff;
	border-radius: 24px;
	box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
	transition: all 0.3s ease;
}

#detailPanel.show {
	flex: 0.7;
	width: 300px;
	padding: 10px;
}

#detailPanel #closeDetail {
	float: right;
	background: white;
	border: none;
	cursor: pointer;
	color: black;
}

#reviewForm {
	display: flex;
	flex-direction: column;
	gap: 10px;
	padding: 15px;
	border: 1px solid #eee;
	border-radius: 10px;
	background: #f9f9f9;
}

#reviewForm label {
	/* font-weight: bold; */
	font-size: 15px;
}

#reviewForm textarea {
	width: 100%;
	border-radius: 10px;
	box-sizing: border-box;
	resize: vertical;
}
/* #reviewForm textarea, */
/* #reviewForm button {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 14px;
        }
        #reviewForm button {
            background-color: #CD853F;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }
        #reviewForm button:hover {
            background-color: #b87a37;
        } */
.star-rating {
	display: inline-block;
}

.star-rating .star {
	cursor: pointer;
	color: #ccc;
	font-size: 24px;
}

.star-rating .star.selected, .star-rating .star.hovered {
	color: #FFD700;
}

.review-actions {
	margin-top: 5px;
	text-align: right;
}
/* .review-actions button {
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
        } */
.update-form {
	display: flex;
	flex-direction: column;
	gap: 8px;
	padding: 10px;
	border: 1px solid #ddd;
	border-radius: 8px;
	margin-top: 10px;
    /* 수정 모드에서는 flex로 보여지고, 평상시에는 JS에서 display: none 처리 */
}

.update-form textarea {
	border: 1px solid #ccc;
	padding: 5px;
	border-radius: 4px;
	width: 100%;
	box-sizing: border-box;
	resize: vertical;
}

/* 💡 추가: 저장/취소 버튼 스타일을 기존 수정/삭제 버튼 스타일과 맞춤 */
.save-btn, .cancel-btn {
	font-size: 16px;
	border-radius: 999px;
	padding: 5px 8px;
	transition: all 0.3s ease;
	cursor: pointer;
   
}

/* 저장 버튼 스타일 (기존 .edit-btn 기반) */
.save-btn {
	border: 2px solid #8B4513; /* 녹색 계열 */
	color: #8B4513;
	background-color: transparent;
}
.save-btn:hover {
	color: white;
	background-color: #8B4513;
}

/* 취소 버튼 스타일 (기존 .delete-btn 기반) */
.cancel-btn {
	border: 2px solid #dc3545; /* 빨간색 계열 */
	color: #dc3545;
	background-color: transparent;
}
.cancel-btn:hover {
	color: white;
	background-color: #dc3545;
}


/* 기존 .btn-fatcat 스타일을 .edit-btn 및 .delete-btn에 적용 */
.delete-btn {
	font-size: 16px;
	border-radius: 999px;
	padding: 5px 8px;
	background-color: transparent;
	color: #dc3545;
	border: 2px solid #dc3545;
	transition: all 0.3s ease;
	cursor: pointer;
}
/* 호버 효과 적용 */
.delete-btn:hover {
	color: white;
	background-color: #dc3545;
	border-color: #dc3545;
}

.edit-btn {
	font-size: 16px;
	border: 2px solid #8B4513;
	padding: 5px 8px;
	border-radius: 999px;
	color: #8B4513; /* 글자색: 새들 브라운 */
	background-color: transparent; /* 배경 투명 */
	transition: all 0.3s ease; /* 부드러운 전환 효과 */
	cursor: pointer;
}

/* 호버 효과 적용 */
.edit-btn:hover {
	color: white;
	background-color: #8B4513;
}

/* 버튼이 들어있는 부모 영역의 font-size: 20px 때문에 버튼이 커지는 것을 방지 */
.review-actions button {
	font-size: 0.75em; /* 부모 크기의 75%로 설정 (약 15px) */
}
</style>
</head>
<body th:data-logged-in-user-seq="${loggedInUserSeq}">
	<div layout:fragment="content">
		<script
			src="//dapi.kakao.com/v2/maps/sdk.js?appkey=4c15890a040537b9e018efed80761b21&libraries=services"></script>

		<div id="controls" style="font-size: 20px;">
			<label>시/도<select id="sido" class="m-1"
				style="font-size: 18px;"></select></label> <label>시/군/구<select
				id="sigungu" class="m-1" style="font-size: 18px;"></select></label> <label>동<select
				id="dong" class="m-1" style="font-size: 18px;"></select></label>
			<button id="searchBtn" class="btn btn-fatcat"
				style="font-size: 20px;">검색</button>
			<button id="btn" class="btn btn-fatcat " style="font-size: 20px;"
				onclick='toggleListView()'>리스트만보기</button>
		</div>

		<div id="mapListContainer">
			<div id="map"></div>
			<div id="menu_wrap">
				<h3 style="font-size: 25px">동물병원 검색 결과</h3>
				<ul id="placesList"></ul>
				<div id="pagination"></div>
			</div>
			<div id="detailPanel">
				<button id="closeDetail">x</button>
				<div id="detailContent"></div>
			</div>
		</div>

		<script>
let REGION_DATA = {}, allPlaces = [], currentPage = 1, pageSize = 7, maxItems = 45;
let openedPlaceId = null, originalCenter = null;
let userLocationMarker = null; // 사용자 위치 마커 변수 추가

const markers = [];
const geocoder = new kakao.maps.services.Geocoder();

const $sido = document.getElementById('sido');
const $sigungu = document.getElementById('sigungu');
const $dong = document.getElementById('dong');
const $searchBtn = document.getElementById('searchBtn');
const $placesList = document.getElementById('placesList');
const $pagination = document.getElementById('pagination');

//🔹 로그인 사용자 SEQ 안전하게 가져오기
const $body = document.querySelector('body');

let LOGGED_IN_USER_SEQ = null;

if ($body.dataset.loggedInUserSeq) {
    const seq = parseInt($body.dataset.loggedInUserSeq, 10);
    if (!isNaN(seq) && seq > 0) {
        LOGGED_IN_USER_SEQ = seq;
    }
}
const map = new kakao.maps.Map(document.getElementById('map'), {
    center: new kakao.maps.LatLng(37.566826, 126.9786567),
    level: 5
});
    const ps = new kakao.maps.services.Places();
    const infowindow = new kakao.maps.InfoWindow({zIndex: 1});

    window.addEventListener('DOMContentLoaded', () => {
        fetch('/data/korea_map_info.txt')
            .then(res => res.text())
            .then(text => { 
                parseCSV(text); 
                fillSido(); 
                
                // 💡 Geolocation 사용 로직을 DOMContentLoaded 시점에 실행
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        pos => {
                            const lat = pos.coords.latitude;
                            const lon = pos.coords.longitude;
                            const loc = new kakao.maps.LatLng(lat, lon);

                            displayUserLocation(lat, lon); // 사용자 위치 마커 표시

                            // 📌 드롭다운 자동 채우기
                            reverseGeocode(lat, lon);

                            // 📌 현재 위치 기준 병원 검색 실행
                            searchNearbyHospitals(loc);
                        },
                        err => console.warn("위치 가져오기 실패", err)
                    );
                }
            })
            .catch(err => console.error('CSV 읽기 실패', err));
    });

    function parseCSV(csvText) {
        REGION_DATA = {};
        csvText.split('\n').slice(1).forEach(line => {
            const [sido, sigungu, dong] = line.split(',').map(s => s.trim());
            if (!sido || !sigungu || !dong) return;
            REGION_DATA[sido] = REGION_DATA[sido] || {};
            REGION_DATA[sido][sigungu] = REGION_DATA[sido][sigungu] || [];
            REGION_DATA[sido][sigungu].push(dong);
        });
    }

    function fillSido() {
        $sido.innerHTML = '<option value="">시/도 선택</option>';
        Object.keys(REGION_DATA).forEach(sd => $sido.innerHTML += `<option value="${sd}">${sd}</option>`);
        $sigungu.innerHTML = '<option value="">시/군/구 선택</option>';
        $dong.innerHTML = '<option value="">동 선택</option>';
    }

    function fillSigungu() {
        const sd = $sido.value;
        $sigungu.innerHTML = '<option value="">시/군/구 선택</option>';
        $dong.innerHTML = '<option value="">동 선택</option>';
        if (!sd) return;
        Object.keys(REGION_DATA[sd]).forEach(gu => $sigungu.innerHTML += `<option value="${gu}">${gu}</option>`);
    }

    function fillDong() {
        const sd = $sido.value, gu = $sigungu.value;
        $dong.innerHTML = '<option value="">동 선택</option>';
        if (!sd || !gu) return;
        REGION_DATA[sd][gu].forEach(d => $dong.innerHTML += `<option value="${d}">${d}</option>`);
    }

    $sido.addEventListener('change', fillSigungu);
    $sigungu.addEventListener('change', fillDong);

    function clearMarkers() {
        markers.forEach(m => {
            m.marker.setMap(null);
            m.overlay.setMap(null);
        });
        markers.length = 0;
    }
    
    // 현재 위치 마커 표시 함수
    function displayUserLocation(lat, lon) {
        const pos = new kakao.maps.LatLng(lat, lon);
        
        if (userLocationMarker) {
            userLocationMarker.setMap(null);
        }

        userLocationMarker = new kakao.maps.Marker({
            position: pos,
            map: map,
        });

        map.setCenter(pos);
    }

    function clearList() {
        $placesList.innerHTML = '';
    }

    function buildRegionText() {
        return [$sido.value, $sigungu.value, $dong.value].filter(Boolean).join(' ');
    }

    function reverseGeocode(lat, lon) {
        geocoder.coord2RegionCode(lon, lat, (result, status) => {
            if (status === kakao.maps.services.Status.OK) {
                const region = result.find(r => r.region_type === "H"); // 행정동 단위

                if (region) {
                    const sido = region.region_1depth_name;
                    const sigungu = region.region_2depth_name;
                    const dong = region.region_3depth_name;

                    // 1) 시/도 선택
                    $sido.value = sido;
                    fillSigungu();

                    // 2) 시/군/구 선택
                    $sigungu.value = sigungu;
                    fillDong();

                    // 3) 동 선택
                    if ([...$dong.options].some(opt => opt.value === dong)) {
                        $dong.value = dong;
                    }
                }
            }
        });
    }


    function searchHospitals() {
    	
    	// ⭐ [추가 시작] 검색 버튼 클릭 시 상세 패널을 닫는 로직
        const detailPanel = document.getElementById('detailPanel');
        if (detailPanel.classList.contains('show')) {
            detailPanel.classList.remove('show');
            // 패널이 닫히면서 열려있던 장소 ID를 초기화합니다.
            openedPlaceId = null; 
        }
        // ⭐ [추가 끝]
        
        if (!$sido.value || !$sigungu.value) {
            alert('시/도와 시/군/구를 선택해주세요.');
            return;
        }
        const keyword = buildRegionText() + ' 동물병원';
        allPlaces = [];
        currentPage = 1;
        const getPlaces = (page = 1) => {
            ps.keywordSearch(keyword, (data, status, pagination) => {
                if (status === kakao.maps.services.Status.OK) {
                    allPlaces = allPlaces.concat(data);
                    if (page < 3 && pagination.hasNextPage) {
                        pagination.nextPage();
                    } else {
                        renderList();
                    }
                } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                    clearMarkers();
                    clearList();
                    $pagination.innerHTML = '';
                    alert('검색 결과가 없습니다.');
                } else {
                    alert('검색 중 오류가 발생했습니다.');
                }
            }, {
                size: 15,
                page
            });
        }
        getPlaces();
    }
    $searchBtn.addEventListener('click', searchHospitals);

    function searchNearbyHospitals(loc) {
        allPlaces = [];
        currentPage = 1;
        ps.keywordSearch("동물병원", (data, status) => {
            if (status === kakao.maps.services.Status.OK) {
                allPlaces = data;
                renderList();
            } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                clearMarkers();
                clearList();
                $pagination.innerHTML = '';
                alert('내 위치 주변에 검색 결과가 없습니다.');
            }
        }, {
            location: loc,
            radius: 500,
            size: 15
        });
    }

    function addMarker(pos, idx,  title = "이름 없음") {
        const marker = new kakao.maps.Marker({
            position: pos,
            map: map,
            image: new kakao.maps.MarkerImage("/images/map_marker.png", new kakao.maps.Size(50, 50))
        });
        const overlay = new kakao.maps.CustomOverlay({
            position: pos,
            content: `<div style="
		                position: absolute;
		                top: 50%;
		                left: 50%;
		                transform: translate(-64%, -80%);
		                font-size: 20px;
		                font-weight: bold;
		                color: #422701;
		                width: 25px;
		                text-align: center;
		            ">${idx + 1}</div>`,
      
        });
        overlay.setMap(map);
        
        // 📌 마커에 마우스 올렸을 때 infoWindow 보이게
        kakao.maps.event.addListener(marker, "mouseover", () => {
            showInfo(marker, title);
        });
        kakao.maps.event.addListener(marker, "mouseout", () => {
            infowindow.close();
        });
        
        markers.push({
            marker,
            overlay
        });
        return {
            marker,
            overlay
        };
    }

    function renderList() {
        clearMarkers();
        clearList();
        const start = (currentPage - 1) * pageSize,
            end = start + pageSize;
        const pagePlaces = allPlaces.slice(start, end);

        pagePlaces.forEach((place, i) => {
            const pos = new kakao.maps.LatLng(place.y, place.x);
            const {
                marker
            } = addMarker(pos, i + start, place.place_name);

            const li = document.createElement('li');
            li.className = 'item';
            li.innerHTML = `
                <div class="marker-number">${i + start + 1}</div>
                <div class="info">
                    <h5>${place.place_name}</h5>
                    <p class="addr">${place.road_address_name || place.address_name || ''}</p>
                    <p class="tel">${place.phone || ''}</p>
                </div>
            `;

            li.addEventListener('mouseover', () => {
                showInfo(marker, place.place_name);
                map.panTo(pos);
            });
            li.addEventListener('mouseout', () => infowindow.close());

            li.addEventListener('click', () => {
                const detailPanel = document.getElementById('detailPanel');
                if (openedPlaceId === place.id) {
                    detailPanel.classList.remove('show');
                    map.panTo(originalCenter || map.getCenter());
                    openedPlaceId = null;
                    return;
                }
                
                const detailContent = document.getElementById('detailContent');
                detailContent.innerHTML = `
                    <button id="closeDetail" class="btn-close" aria-label="Close"></button>
                    <div id="clinicInfo" style="font-size : 20px">
                			<strong style="font-size : 25px">${place.place_name}</strong>
                        <p>주소:${place.road_address_name || place.address_name}</p>
                        <p>전화:${place.phone || '정보 없음'}</p>
                    </div>
                    <hr>
                    <div id="reviewSection">
                        <div id="ratingInfo">
                            <h5 ><strong>평점</strong>: <span id="avgRating">...</span></h5>
                        </div>
                        <hr>
                        <strong style="font-size : 25px;">리뷰 작성하기</strong>
                        <form id="reviewForm">
                            <input type="hidden" id="placeNameInput" name="placeName" value="${place.place_name}">
                            <input type="hidden" id="addressInput" name="address" value="${place.address_name || place.road_address_name}">
                            
                            <div class="form-group" >
                                <label style="font-size : 20px;" >별점:</label>
                                <div id="ratingStars" class="star-rating">
                                    <span class="star" data-rating="1">★</span>
                                    <span class="star" data-rating="2">★</span>
                                    <span class="star" data-rating="3">★</span>
                                    <span class="star" data-rating="4">★</span>
                                    <span class="star" data-rating="5">★</span>
                                </div>
                                <input type="hidden" id="ratingInput" name="rating" required>
                            </div>
                            
                            <div class="form-group">
                                <label style="font-size : 20px;">리뷰:</label>
                                <textarea id="reviewContentInput" name="reviewContent" rows="3" class="form-control" required></textarea>
                            </div>
                            
                            <button type="submit" class="btn btn-fatcat" style="font-size : 20px;">리뷰 등록</button>
                        </form>
                        <hr>
                        <div id="reviewList">
                            <strong style="font-size : 25px;">등록된 리뷰</strong>
                            <p  style="font-size : 20px;">... 리뷰 로딩 중 ...</p>
                        </div>
                    </div>
                `;
                
                // 'X' 버튼 클릭 시 닫기
                document.getElementById('closeDetail').onclick = () => {
                    detailPanel.classList.remove('show');
                    map.panTo(originalCenter || map.getCenter());
                    openedPlaceId = null;
                };

                fetchReviews(place.place_name, place.address_name || place.road_address_name);
                setupStarRating();
                document.getElementById('reviewForm').addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData(this);
                    const reviewData = {
                        placeName: formData.get('placeName'),
                        address: formData.get('address'),
                        reviewContent: formData.get('reviewContent'),
                        rating: parseInt(formData.get('rating'))
                    };
                    submitReview(reviewData);
                });

                detailPanel.classList.add('show');
                if (!originalCenter) originalCenter = map.getCenter();
                map.panBy(-detailPanel.offsetWidth / 2, 0);
                openedPlaceId = place.id;
            });
            $placesList.appendChild(li);
        });


        renderPagination();

        // ⭐ [수정] 지도 경계 설정 로직: 현재 페이지의 마커들을 기준으로 지도 경계를 설정
        if (document.getElementById('map').style.display !== 'none' && pagePlaces.length > 0) { 
            const bounds = new kakao.maps.LatLngBounds();
            pagePlaces.forEach(p => bounds.extend(new kakao.maps.LatLng(p.y, p.x)));
            map.setBounds(bounds, 20); // 20은 패딩 값
        }
    }

    function renderPagination() {
        $pagination.innerHTML = '';
        const totalPages = Math.ceil(allPlaces.length / pageSize);
        for (let i = 1; i <= totalPages; i++) {
            const a = document.createElement('a');
            a.href = '#';
            a.textContent = i;
            if (i === currentPage) a.className = 'on';
            else a.addEventListener('click', e => {
                e.preventDefault();
                currentPage = i;
                renderList();
            });
            $pagination.appendChild(a);
        }
    }

    function showInfo(marker, title) {
        infowindow.setContent('<div style="padding:5px;font-size:13px;">' + title + '</div>');
        infowindow.open(map, marker);
    }

    function toggleListView() {
        const mapDiv = document.getElementById('map');
        const btn = document.getElementById('btn');
        const menuWrap = document.getElementById('menu_wrap');
        if (mapDiv.style.display !== 'none') {
            mapDiv.style.display = 'none';
            btn.innerText = '지도랑 같이 보기';
            $placesList.style.display = 'grid';
            $placesList.style.gridTemplateColumns = 'repeat(3,1fr)';
            $placesList.style.gap = '10px';
            pageSize = 15;
            currentPage = 1;
            menuWrap.style.flex = '1';
            renderList();
        } else {
            mapDiv.style.display = 'block';
            btn.innerText = '리스트만 보기';
            kakao.maps.event.trigger(map, 'resize');
            $placesList.style.display = 'block';
            $placesList.style.gridTemplateColumns = 'none';
            $placesList.style.gap = '0';
            pageSize = 7;
            currentPage = 1;
            menuWrap.style.flex = '0.5';
            kakao.maps.event.trigger(map, 'resize');
            renderList();
        }
    }

    function setupStarRating() {
        const starsDiv = document.getElementById('ratingStars');
        starsDiv.innerHTML = '★★★★★'.split('').map((star, i) => `<span class="star" data-rating="${i+1}">${star}</span>`).join('');
        const stars = starsDiv.querySelectorAll('.star');
        const ratingInput = document.getElementById('ratingInput');
        stars.forEach(star => {
            star.addEventListener('click', function() {
                const rating = this.dataset.rating;
                ratingInput.value = rating;
                stars.forEach(s => s.classList.toggle('selected', s.dataset.rating <= rating));
            });
        });
    }
    
    async function updateReview(vetReviewSeq, newContent, newRating) {
        try {
            const response = await fetch(`/api/vet-clinics/reviews/${vetReviewSeq}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reviewContent: newContent, rating: parseInt(newRating) })
            });
            if (response.ok) {
                // 💡 성공 시 alert 대신 커스텀 메시지 사용 권장 (현재는 alert 유지)
                alert('리뷰가 성공적으로 수정되었습니다.');
                // 수정 완료 후, 리스트를 다시 불러와 '저장/취소' 버튼을 '수정/삭제'로 복구
                fetchReviews(document.getElementById('placeNameInput').value, document.getElementById('addressInput').value);
            } else { 
                const errorText = await response.text();
                alert(`리뷰 수정에 실패했습니다: ${errorText} (상태코드: ${response.status})`); 
            }
        } catch (error) { alert('네트워크 오류로 리뷰 수정에 실패했습니다.'); }
    }

    async function deleteReview(vetReviewSeq) {

        if (!confirm('정말로 이 리뷰를 삭제하시겠습니까?')) return;
        try {
            const response = await fetch(`/api/vet-clinics/reviews/${vetReviewSeq}`, { method: 'DELETE' });
            if (response.ok) {
                alert('리뷰가 성공적으로 삭제되었습니다.');
                fetchReviews(document.getElementById('placeNameInput').value, document.getElementById('addressInput').value);
            } else { 
                 const errorText = await response.text();
                 // 💡 HTTP 상태 코드 추가
                 alert(`리뷰 삭제에 실패했습니다: ${errorText} (상태코드: ${response.status})`); 
            }
        } catch (error) { alert('네트워크 오류로 리뷰 삭제에 실패했습니다.'); }
    }
    
    async function fetchReviews(placeName, address) {
        try {
            const params = new URLSearchParams({ placeName, address });
            const response = await fetch(`/api/vet-clinics/reviews?${params.toString()}`);
            const data = await response.json();

            // ⭐ [추가] 최신 날짜(createDate) 기준으로 내림차순 정렬
            if (data.reviews && data.reviews.length > 0) {
                data.reviews.sort((a, b) => new Date(b.createDate) - new Date(a.createDate));
            }
            
            const avgRatingEl = document.getElementById('avgRating');
            const reviewListEl = document.getElementById('reviewList');
            
            // 💡 평균 평점 별표 표시 로직
            if (data.ratingAvg !== null) {
                const avgRating = parseFloat(data.ratingAvg).toFixed(1); 
                const starCount = Math.round(data.ratingAvg); 
                
                const filledStars = '<span style="color:#FFD700;">' + '★'.repeat(starCount) + '</span>';
                const emptyStars = '<span style="color:#CCCCCC;">' + '★'.repeat(5 - starCount) + '</span>';
                const starDisplay = filledStars + emptyStars;
                
                avgRatingEl.innerHTML = `${avgRating}점 ${starDisplay} (${data.ratingCount}명 참여)`;
            } else {
                avgRatingEl.textContent = "아직 평점이 없습니다.";
            }

            reviewListEl.innerHTML = `<strong style="font-size : 25px;">등록된 리뷰</strong>`;

            if (data.reviews && data.reviews.length > 0) {
                data.reviews.forEach(review => {
                    // 💡 현재 로그인 사용자가 이 리뷰의 작성자인지 확인
                    const isAuthor = LOGGED_IN_USER_SEQ && LOGGED_IN_USER_SEQ === review.userSeq;

                    // 💡 DTO의 'userName' 필드를 사용하여 작성자 이름을 표시 (익명 문제 해결)
                    const authorName = review.userName || '익명';
                    
                    // ⭐ 버튼에 data-action="edit" / "delete" 속성 추가
                    const actionButtons = isAuthor ? `
                        <div class="review-actions d-flex justify-content-end" style="font-size : 20px; display: flex; gap: 5px;">
                            <button class="btn btn-outline-brown btn-sm edit-btn" data-action="edit" style="font-size: 16px;">수정</button>
                            <button class="btn btn-outline-danger btn-sm delete-btn" data-action="delete" style="font-size: 16px;">삭제</button>
                        </div>
                    ` : '';
                    
                    const reviewItem = document.createElement('div');
                    reviewItem.id = `review-${review.vetReviewSeq}`;
                    reviewItem.innerHTML = `
                        <p class="review-meta" style="font-size : 20px; color:#555555;">작성자: ${authorName} | 별점: ${'★'.repeat(review.vetRating)}</strong> | 작성일자: ${review.createDate}</p>
                        <p class="review-text" style="font-size : 20px;">${review.vetReview}</p>
                        
                        ${actionButtons}
                        <hr>
                    `;
                    reviewListEl.appendChild(reviewItem);

                    // 💡 버튼이 생성된 경우에만 이벤트 리스너 연결
                    if (isAuthor) {
                        const editBtn = reviewItem.querySelector('.edit-btn');
                        const deleteBtn = reviewItem.querySelector('.delete-btn');
                        
                        // 이 리스너는 수정 모드 진입 기능을 담당합니다.
                        editBtn.addEventListener('click', () => {
                             // data-action을 확인하여 '수정' 모드일 때만 진입
                            if (editBtn.dataset.action === 'edit') {
                                handleUpdateReview(review.vetReviewSeq, review.vetReview, review.vetRating);
                            }
                        });
                        // 삭제 버튼 리스너
                        deleteBtn.addEventListener('click', () => {
                             // data-action을 확인하여 '삭제' 모드일 때만 실행
                             if (deleteBtn.dataset.action === 'delete') {
                                deleteReview(review.vetReviewSeq);
                             }
                        });
                    }
                });
            } else {
                reviewListEl.innerHTML += `<p  style="font-size : 20px;">등록된 리뷰가 없습니다.</p>`;
            }
        } catch (error) {
            console.error('리뷰 정보를 가져오는 데 실패했습니다.', error);
            document.getElementById('reviewList').innerHTML = `<p>리뷰 정보를 가져올 수 없습니다.</p>`;
        }
    }
    
    // ⭐ 별점 설정 HTML을 생성하는 헬퍼 함수
    function createUpdateFormContent(content, rating) {
        return `
            <div class="form-group" style="font-size : 20px;">
                <label >별점:</label>
                <div class="star-rating update-stars">
                    ${'★'.repeat(5).split('').map((star, i) => 
                        `<span class="star" data-rating="${i+1}" style="color:${i+1 <= rating ? '#FFD700' : '#ccc'};">${star}</span>`
                    ).join('')}
                </div>
                <input type="hidden" class="update-rating-input" value="${rating}">
            </div>
            <div class="form-group">
                <label style="font-size : 20px;">내용:</label>
                <textarea class="update-content-input form-control" style="font-size : 20px;" rows="3">${content}</textarea>
            </div>
        `;
    }

    // ⭐ 수정 폼의 별점 이벤트 리스너 설정 함수
    function setupUpdateStarRating(formElement, initialRating) {
        const updateStars = formElement.querySelectorAll('.star-rating .star');
        const updateRatingInput = formElement.querySelector('.update-rating-input');

        // 별점 클릭 이벤트 설정
        updateStars.forEach(star => {
            star.addEventListener('click', function() {
                const newRating = parseInt(this.dataset.rating);
                updateRatingInput.value = newRating;
                updateStars.forEach(s => {
                    s.style.color = parseInt(s.dataset.rating) <= newRating ? '#FFD700' : '#ccc';
                });
            });
        });
    }

    // ⭐ 수정 모드를 종료하고 버튼과 내용을 원상 복구하는 헬퍼 함수
    function exitUpdateMode(vetReviewSeq, originalEditHandler, originalDeleteHandler) {
        const reviewItem = document.getElementById(`review-${vetReviewSeq}`);
        const updateForm = reviewItem.querySelector('.update-form-container');
        
        // ⭐ [추가] 숨겼던 리뷰 내용 다시 표시
        const reviewMeta = reviewItem.querySelector('.review-meta');
        const reviewText = reviewItem.querySelector('.review-text');
        const hr = reviewItem.querySelector('hr:last-of-type');

        if (reviewMeta) reviewMeta.style.display = 'block'; 
        if (reviewText) reviewText.style.display = 'block'; 
        if (hr) hr.style.display = 'block'; 
        // ⭐ [추가 끝]
        
        const saveBtn = reviewItem.querySelector('.review-actions button[data-action="save"]');
        const cancelBtn = reviewItem.querySelector('.review-actions button[data-action="cancel"]');
        
        // 1. 폼 제거
        if (updateForm) updateForm.remove();

    
        // 3. 버튼 텍스트와 기능 복구 (저장 -> 수정, 취소 -> 삭제)
        
        // '저장' 버튼을 '수정'으로 복구
        saveBtn.textContent = '수정';
        saveBtn.classList.remove('save-btn');
        saveBtn.classList.add('edit-btn');
        saveBtn.dataset.action = 'edit';
        saveBtn.onclick = originalEditHandler; // 원래 이벤트 리스너 복구
        
        // '취소' 버튼을 '삭제'로 복구
        cancelBtn.textContent = '삭제';
        cancelBtn.classList.remove('cancel-btn');
        cancelBtn.classList.add('delete-btn');
        cancelBtn.dataset.action = 'delete';
        cancelBtn.onclick = originalDeleteHandler; // 원래 이벤트 리스너 복구
    }


    // ⭐ 수정된 handleUpdateReview 함수 (수정 모드 진입 로직)
    function handleUpdateReview(vetReviewSeq, reviewContent, rating) {
        const reviewItem = document.getElementById(`review-${vetReviewSeq}`);
        const reviewText = reviewItem.querySelector('.review-text');

        // 기존에 열려있는 폼이 있다면 닫기
        const existingForm = reviewItem.querySelector('.update-form-container');
        if(existingForm) existingForm.remove();

        // ⭐ [추가 시작] 기존 리뷰 내용 숨기기
        const reviewMeta = reviewItem.querySelector('.review-meta');
        const hr = reviewItem.querySelector('hr:last-of-type'); 
        
        if (reviewMeta) reviewMeta.style.display = 'none';
        if (reviewText) reviewText.style.display = 'none';
        if (hr) hr.style.display = 'none';
        // ⭐ [추가 끝]

        const editBtn = reviewItem.querySelector('.edit-btn');
        const deleteBtn = reviewItem.querySelector('.delete-btn');
        
        // 기존 이벤트 핸들러를 저장합니다. (exitUpdateMode에서 복구하기 위함)
        const originalEditHandler = editBtn.onclick;
        const originalDeleteHandler = deleteBtn.onclick;

      
        
        // 2. 수정 폼 생성 및 삽입
        const updateFormContainer = document.createElement('div');
        updateFormContainer.className = 'update-form-container update-form';
        updateFormContainer.innerHTML = createUpdateFormContent(reviewContent, rating);
        
        // 💡 리뷰 텍스트 바로 뒤에 폼 삽입
        reviewText.insertAdjacentElement('afterend', updateFormContainer);
        
        // 3. 버튼 텍스트와 기능 변경 (수정 -> 저장, 삭제 -> 취소)
        
        // 3-1. '수정' -> '저장' 버튼으로 변경
        editBtn.textContent = '저장';
        editBtn.classList.add('save-btn');
        editBtn.classList.remove('edit-btn');
        editBtn.dataset.action = 'save'; // 액션 변경
        
        editBtn.onclick = async () => {
            const newContent = updateFormContainer.querySelector('.update-content-input').value;
            const newRating = updateFormContainer.querySelector('.update-rating-input').value;
            
            // 저장 로직 호출
            try {
                // updateReview는 성공 시 fetchReviews를 호출하여 리스트 전체를 갱신합니다.
                // 갱신 과정에서 버튼의 이벤트 리스너가 fetchReviews에서 다시 설정되어 복구됩니다.
                await updateReview(vetReviewSeq, newContent, newRating);
            } catch (error) {
                // 실패 시 모드 유지 (사용자가 수정할 수 있도록)
                console.error("업데이트 실패:", error);
            }
        };

        // 3-2. '삭제' -> '취소' 버튼으로 변경
        deleteBtn.textContent = '취소';
        deleteBtn.classList.add('cancel-btn');
        deleteBtn.classList.remove('delete-btn');
        deleteBtn.dataset.action = 'cancel'; // 액션 변경
        
        deleteBtn.onclick = () => {
            // 취소 로직 호출: 원본 핸들러를 전달하여 복구
            exitUpdateMode(vetReviewSeq, originalEditHandler, originalDeleteHandler);
        };

        // 4. 별점 설정 및 이벤트 리스너 연결
        setupUpdateStarRating(updateFormContainer, rating);
    }
    
    async function submitReview(reviewData) {
        if (LOGGED_IN_USER_SEQ === null) {
            alert('리뷰 작성은 로그인 후 이용 가능합니다.');
            return;
        }
        try {
            const response = await fetch('/api/vet-clinics/reviews', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(reviewData)
            });
            if (response.ok) {
                alert('리뷰가 성공적으로 등록되었습니다.');
                document.getElementById('reviewContentInput').value = '';
                document.getElementById('ratingInput').value = '';
                document.querySelectorAll('#ratingStars .star').forEach(s => s.classList.remove('selected'));
                fetchReviews(reviewData.placeName, reviewData.address);
            } else { 
                const errorText = await response.text();
                alert(`리뷰 등록에 실패했습니다. (상태코드: ${response.status}): ${errorText}`); 
            }
        } catch (error) { 
            console.error(error);
            alert('네트워크 오류로 리뷰 등록에 실패했습니다.'); 
        }
    }
</script>
	</div>
</body>
</html>
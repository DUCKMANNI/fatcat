<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
	xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
	layout:decorate="~{shared/layout}">
<head>
<meta charset="utf-8">
<title>동물병원 검색</title>
<style>
/* CSS 스타일 */
#controls {
	background: rgba(255, 255, 255, 0.96);
	border: 1px solid #ddd;
	border-radius: 14px;
	padding: 10px 14px;
	display: flex;
	gap: 8px;
	align-items: center;
	margin: 20px auto;
	width: fit-content;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
}

#controls select {
	height: 36px;
	font-size: 20px;
	border-radius: 8px;
	border: 1px solid #ccc;
	margin: 5px auto;
	padding: 0 10px;
}
/*  #controls button {
            cursor: pointer;
            border: none;
            background: #CD853F;
            color: #fff;
            font-weight: 600;
        } */
        
#mapListContainer {
	display: flex;
	width: calc(100% - 20px);
	height: 80vh;
	margin: 20px 15px 0;
	gap: 16px;
	box-sizing: border-box;
}

#map, #menu_wrap, #detailPanel {
	transition: all 0.3s ease;
}

#map {
	flex: 0.9;
	height: 100%;
	border: 1px solid #e5e5e5;
	border-radius: 24px;
	position: relative;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
}

#menu_wrap {
	flex: 0.5;
	background: rgba(255, 255, 255, 0.96);
	border-radius: 24px;
	padding: 8px;
	font-size: 14px;
	overflow-y: auto;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
}

#menu_wrap h3 {
	margin: 6px 8px 10px;
	font-size: 16px;
}

#placesList {
	margin: 0;
	padding: 0 6px 8px;
}

#placesList li {
	list-style: none;
}

#placesList .item {
	display: flex;
	align-items: flex-start;
	padding: 10px;
	border-bottom: 1px solid #ddd;
	cursor: pointer;
}

#placesList .marker-number {
	width: 23px;
	height: 23px;
	display: flex;
	align-items: center;
	justify-content: center;
	background: #D2B48C;
	color: white;
	border-radius: 20px;
	font-size: 13px;
	font-weight: bold;
	margin-right: 10px;
	flex-shrink: 0;
}

#placesList .info {
	flex: 1;
}

#placesList .info h5 {
	margin: 0 0 4px;
	font-size: 20px;
	font-weight: bold;
}

#placesList .info p {
	margin: 2px 0;
	font-size: 18px;
	color: #555;
}

#pagination {
	text-align: center;
	padding: 6px 0 10px;
}

#pagination a {
	display: inline-block;
	margin: 0 6px;
	text-decoration: none;
	color: #666;
}

#pagination .on {
	font-weight: 700;
	color: #6C3C30;
	pointer-events: none;
}
/*  .fixed-element button {
            display: block !important;
        } */
#detailPanel {
	flex: 0;
	width: 0;
	padding: 0;
	overflow-y: auto;
	background: #fff;
	border-radius: 24px;
	box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
	transition: all 0.3s ease;
}

#detailPanel.show {
	flex: 0.7;
	width: 300px;
	padding: 10px;
}

#detailPanel #closeDetail {
	float: right;
	background: white;
	border: none;
	cursor: pointer;
	color: black;
}

#reviewForm {
	display: flex;
	flex-direction: column;
	gap: 10px;
	padding: 15px;
	border: 1px solid #eee;
	border-radius: 10px;
	background: #f9f9f9;
}

#reviewForm label {
	/* font-weight: bold; */
	font-size: 15px;
}

#reviewForm textarea {
	width: 100%;
	border-radius: 10px;
	box-sizing: border-box;
	resize: vertical;
}
/*   #reviewForm textarea, */
/*     #reviewForm button {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 14px;
        }
        #reviewForm button {
            background-color: #CD853F;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }
        #reviewForm button:hover {
            background-color: #b87a37;
        } */
.star-rating {
	display: inline-block;
}

.star-rating .star {
	cursor: pointer;
	color: #ccc;
	font-size: 24px;
}

.star-rating .star.selected, .star-rating .star.hovered {
	color: #FFD700;
}

.review-actions {
	margin-top: 5px;
	text-align: right;
}
/*   .review-actions button {
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 12px;
            cursor: pointer;
        } */
.update-form {
	display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    padding: 0 10px;
    border: 1px solid #ddd;
    border-radius: 8px;
    margin-top: 10px;
    transition: max-height 0.4s ease, opacity 0.4s ease, padding 0.4s ease;
}

.update-form.show {
    max-height: 500px; /* 충분히 큰 값 */
    opacity: 1;
    padding: 10px; 
    
}

.update-form textarea {
	border: 1px solid #ccc;
	padding: 5px;
	border-radius: 4px;
	width: 100%;
	box-sizing: border-box;
	resize: vertical;
}
/*       .update-form button {
            border: none;
            padding: 6px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .update-form .save-btn {
            background-color: #28a745;
            color: white;
        }
        .update-form .cancel-btn {
            background-color: #dc3545;
            color: white;
        } */

/* 기존 .btn-fatcat 스타일을 .edit-btn 및 .delete-btn에 적용 */
.delete-btn {
	font-size: 16px;
	border-radius: 999px;
	padding: 5px 8px;
	background-color: transparent;
	color: #dc3545;
	border: 2px solid #dc3545;
	transition: all 0.3s ease;
	cursor: pointer;
}
/* 호버 효과 적용 */
.delete-btn:hover {
	color: white;
	background-color: #dc3545;
	border-color: #dc3545;
}

.edit-btn {
	font-size: 16px;
	border: 2px solid #8B4513;
	padding: 5px 8px;
	border-radius: 999px;
	color: #8B4513; /* 글자색: 새들 브라운 */
	background-color: transparent; /* 배경 투명 */
	transition: all 0.3s ease; /* 부드러운 전환 효과 */
	cursor: pointer;
}

/* 호버 효과 적용 */
.edit-btn:hover {
	color: white;
	background-color: #8B4513;
}

/* 버튼이 들어있는 부모 영역의 font-size: 20px 때문에 버튼이 커지는 것을 방지 */
.review-actions button {
	font-size: 0.75em; /* 부모 크기의 75%로 설정 (약 15px) */
}

/* .review-actions의 display 설정을 CSS로 명시 (인라인 스타일 제거 권장) */
.review-actions {
    margin-top: 5px;
    text-align: right;
    display: flex; /* 기본값 */
    justify-content: flex-end; /* 기존 인라인 스타일 유지 */
    gap: 5px; /* 기존 인라인 스타일 유지 */
}

/* 수정 폼이 나타나면서 리뷰 내용 숨기기 위한 클래스 */
.review-item-content-hide {
    display: none !important; /* 내용 숨김 시 확실하게 적용 */
}

/* 수정 버튼 영역 숨김/보임을 JS에서 확실히 제어하기 위한 클래스 */
.review-actions.hidden-by-js {
    display: none !important; /* 버튼 숨김 시 확실하게 적용 */
}
</style>
</head>
<body th:data-logged-in-user-seq="${loggedInUserSeq}">
	<div layout:fragment="content">
		<script
			src="//dapi.kakao.com/v2/maps/sdk.js?appkey=4c15890a040537b9e018efed80761b21&libraries=services"></script>

		<div id="controls" style="font-size: 20px;">
			<label>시/도<select id="sido" class="m-1"
				style="font-size: 18px;"></select></label> <label>시/군/구<select
				id="sigungu" class="m-1" style="font-size: 18px;"></select></label> <label>동<select
				id="dong" class="m-1" style="font-size: 18px;"></select></label>
			<button id="searchBtn" class="btn btn-fatcat"
				style="font-size: 20px;">검색</button>
			<button id="btn" class="btn btn-fatcat " style="font-size: 20px;"
				onclick='toggleListView()'>리스트만보기</button>
		</div>

		<div id="mapListContainer">
			<div id="map"></div>
			<div id="menu_wrap">
				<h3 style="font-size: 25px">동물병원 검색 결과</h3>
				<ul id="placesList"></ul>
				<div id="pagination"></div>
			</div>
			<div id="detailPanel">
				<button id="closeDetail">x</button>
				<div id="detailContent"></div>
			</div>
		</div>

		<script>
let REGION_DATA = {}, allPlaces = [], currentPage = 1, pageSize = 7, maxItems = 45;
let openedPlaceId = null, originalCenter = null;
let userLocationMarker = null; // 사용자 위치 마커 변수 추가

const markers = [];
const geocoder = new kakao.maps.services.Geocoder();

const $sido = document.getElementById('sido');
const $sigungu = document.getElementById('sigungu');
const $dong = document.getElementById('dong');
const $searchBtn = document.getElementById('searchBtn');
const $placesList = document.getElementById('placesList');
const $pagination = document.getElementById('pagination');

//🔹 로그인 사용자 SEQ 안전하게 가져오기
const $body = document.querySelector('body');

let LOGGED_IN_USER_SEQ = null;

if ($body.dataset.loggedInUserSeq) {
    const seq = parseInt($body.dataset.loggedInUserSeq, 10);
    if (!isNaN(seq) && seq > 0) {
        LOGGED_IN_USER_SEQ = seq;
    }
}
const map = new kakao.maps.Map(document.getElementById('map'), {
    center: new kakao.maps.LatLng(37.566826, 126.9786567),
    level: 5
});
    const ps = new kakao.maps.services.Places();
    const infowindow = new kakao.maps.InfoWindow({zIndex: 1});

    window.addEventListener('DOMContentLoaded', () => {
        fetch('/data/korea_map_info.txt')
            .then(res => res.text())
            .then(text => { 
                parseCSV(text); 
                fillSido(); 
                
                // 💡 Geolocation 사용 로직을 DOMContentLoaded 시점에 실행
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        pos => {
                            const lat = pos.coords.latitude;
                            const lon = pos.coords.longitude;
                            const loc = new kakao.maps.LatLng(lat, lon);

                            displayUserLocation(lat, lon); // 사용자 위치 마커 표시

                            // 📌 드롭다운 자동 채우기
                            reverseGeocode(lat, lon);

                            // 📌 현재 위치 기준 병원 검색 실행
                            searchNearbyHospitals(loc);
                        },
                        err => console.warn("위치 가져오기 실패", err)
                    );
                }
            })
            .catch(err => console.error('CSV 읽기 실패', err));
    });

    function parseCSV(csvText) {
        REGION_DATA = {};
        csvText.split('\n').slice(1).forEach(line => {
            const [sido, sigungu, dong] = line.split(',').map(s => s.trim());
            if (!sido || !sigungu || !dong) return;
            REGION_DATA[sido] = REGION_DATA[sido] || {};
            REGION_DATA[sido][sigungu] = REGION_DATA[sido][sigungu] || [];
            REGION_DATA[sido][sigungu].push(dong);
        });
    }

    function fillSido() {
        $sido.innerHTML = '<option value="">시/도 선택</option>';
        Object.keys(REGION_DATA).forEach(sd => $sido.innerHTML += `<option value="${sd}">${sd}</option>`);
        $sigungu.innerHTML = '<option value="">시/군/구 선택</option>';
        $dong.innerHTML = '<option value="">동 선택</option>';
    }

    function fillSigungu() {
        const sd = $sido.value;
        $sigungu.innerHTML = '<option value="">시/군/구 선택</option>';
        $dong.innerHTML = '<option value="">동 선택</option>';
        if (!sd) return;
        Object.keys(REGION_DATA[sd]).forEach(gu => $sigungu.innerHTML += `<option value="${gu}">${gu}</option>`);
    }

    function fillDong() {
        const sd = $sido.value, gu = $sigungu.value;
        $dong.innerHTML = '<option value="">동 선택</option>';
        if (!sd || !gu) return;
        REGION_DATA[sd][gu].forEach(d => $dong.innerHTML += `<option value="${d}">${d}</option>`);
    }

    $sido.addEventListener('change', fillSigungu);
    $sigungu.addEventListener('change', fillDong);

    function clearMarkers() {
        markers.forEach(m => {
            m.marker.setMap(null);
            m.overlay.setMap(null);
        });
        markers.length = 0;
    }
    
    // 현재 위치 마커 표시 함수
    function displayUserLocation(lat, lon) {
        const pos = new kakao.maps.LatLng(lat, lon);
        
        if (userLocationMarker) {
            userLocationMarker.setMap(null);
        }

        userLocationMarker = new kakao.maps.Marker({
            position: pos,
            map: map,
        });

        map.setCenter(pos);
    }

    function clearList() {
        $placesList.innerHTML = '';
    }

    function buildRegionText() {
        return [$sido.value, $sigungu.value, $dong.value].filter(Boolean).join(' ');
    }

    function reverseGeocode(lat, lon) {
        geocoder.coord2RegionCode(lon, lat, (result, status) => {
            if (status === kakao.maps.services.Status.OK) {
                const region = result.find(r => r.region_type === "H"); // 행정동 단위

                if (region) {
                    const sido = region.region_1depth_name;
                    const sigungu = region.region_2depth_name;
                    const dong = region.region_3depth_name;

                    // 1) 시/도 선택
                    $sido.value = sido;
                    fillSigungu();

                    // 2) 시/군/구 선택
                    $sigungu.value = sigungu;
                    fillDong();

                    // 3) 동 선택
                    if ([...$dong.options].some(opt => opt.value === dong)) {
                        $dong.value = dong;
                    }
                }
            }
        });
    }


    function searchHospitals() {
        if (!$sido.value || !$sigungu.value) {
            alert('시/도와 시/군/구를 선택해주세요.');
            return;
        }
        const keyword = buildRegionText() + ' 동물병원';
        allPlaces = [];
        currentPage = 1;
        const getPlaces = (page = 1) => {
            ps.keywordSearch(keyword, (data, status, pagination) => {
                if (status === kakao.maps.services.Status.OK) {
                    allPlaces = allPlaces.concat(data);
                    if (page < 3 && pagination.hasNextPage) {
                        pagination.nextPage();
                    } else {
                        renderList();
                    }
                } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                    clearMarkers();
                    clearList();
                    $pagination.innerHTML = '';
                    alert('검색 결과가 없습니다.');
                } else {
                    alert('검색 중 오류가 발생했습니다.');
                }
            }, {
                size: 15,
                page
            });
        }
        getPlaces();
    }
    $searchBtn.addEventListener('click', searchHospitals);

    function searchNearbyHospitals(loc) {
        allPlaces = [];
        currentPage = 1;
        ps.keywordSearch("동물병원", (data, status) => {
            if (status === kakao.maps.services.Status.OK) {
                allPlaces = data;
                renderList();
            } else if (status === kakao.maps.services.Status.ZERO_RESULT) {
                clearMarkers();
                clearList();
                $pagination.innerHTML = '';
                alert('내 위치 주변에 검색 결과가 없습니다.');
            }
        }, {
            location: loc,
            radius: 500,
            size: 15
        });
    }

    function addMarker(pos, idx,  title = "이름 없음") {
        const marker = new kakao.maps.Marker({
            position: pos,
            map: map,
            image: new kakao.maps.MarkerImage("/images/map_marker.png", new kakao.maps.Size(50, 50))
        });
        const overlay = new kakao.maps.CustomOverlay({
            position: pos,
            content: `<div style="
		                position: absolute;
		                top: 50%;
		                left: 50%;
		                transform: translate(-64%, -80%);
		                font-size: 20px;
		                font-weight: bold;
		                color: #422701;
		                width: 25px;
		                text-align: center;
		            ">${idx + 1}</div>`,
      
        });
        overlay.setMap(map);
        
        // 📌 마커에 마우스 올렸을 때 infoWindow 보이게
        kakao.maps.event.addListener(marker, "mouseover", () => {
            showInfo(marker, title);
        });
        kakao.maps.event.addListener(marker, "mouseout", () => {
            infowindow.close();
        });
        
        markers.push({
            marker,
            overlay
        });
        return {
            marker,
            overlay
        };
    }

    function renderList() {
    	
    	// 🔹 검색 시 이전 상세창 닫기
        const detailPanel = document.getElementById('detailPanel');
        detailPanel.classList.remove('show');
        openedPlaceId = null;
        
        clearMarkers();
        clearList();
        const start = (currentPage - 1) * pageSize,
            end = start + pageSize;
        const pagePlaces = allPlaces.slice(start, end);

        pagePlaces.forEach((place, i) => {
            const pos = new kakao.maps.LatLng(place.y, place.x);
            const {
                marker
            } = addMarker(pos, i + start, place.place_name);

            const li = document.createElement('li');
            li.className = 'item';
            li.innerHTML = `
                <div class="marker-number">${i + start + 1}</div>
                <div class="info">
                    <h5>${place.place_name}</h5>
                    <p class="addr">${place.road_address_name || place.address_name || ''}</p>
                    <p class="tel">${place.phone || ''}</p>
                </div>
            `;

            li.addEventListener('mouseover', () => {
                showInfo(marker, place.place_name);
                map.panTo(pos);
            });
            li.addEventListener('mouseout', () => infowindow.close());

            li.addEventListener('click', () => {
                const detailPanel = document.getElementById('detailPanel');
                if (openedPlaceId === place.id) {
                    detailPanel.classList.remove('show');
                    map.panTo(originalCenter || map.getCenter());
                    openedPlaceId = null;
                    return;
                }
                
                const detailContent = document.getElementById('detailContent');
                detailContent.innerHTML = `
                    <button id="closeDetail" class="btn-close" aria-label="Close"></button>
                    <div id="clinicInfo" style="font-size : 20px">
                			<strong style="font-size : 25px">${place.place_name}</strong>
                        <p>주소:${place.road_address_name || place.address_name}</p>
                        <p>전화:${place.phone || '정보 없음'}</p>
                    </div>
                    <hr>
                    <div id="reviewSection">
                        <div id="ratingInfo">
                            <h5 ><strong>평점</strong>: <span id="avgRating">...</span></h5>
                        </div>
                        <hr>
                        <strong style="font-size : 25px;">리뷰 작성하기</strong>
                        <form id="reviewForm">
                            <input type="hidden" id="placeNameInput" name="placeName" value="${place.place_name}">
                            <input type="hidden" id="addressInput" name="address" value="${place.address_name || place.road_address_name}">
                            
                            <div class="form-group" >
                                <label style="font-size : 20px;" >별점:</label>
                                <div id="ratingStars" class="star-rating">
                                    <span class="star" data-rating="1">★</span>
                                    <span class="star" data-rating="2">★</span>
                                    <span class="star" data-rating="3">★</span>
                                    <span class="star" data-rating="4">★</span>
                                    <span class="star" data-rating="5">★</span>
                                </div>
                                <input type="hidden" id="ratingInput" name="rating" required>
                            </div>
                            
                            <div class="form-group">
                                <label style="font-size : 20px;">리뷰:</label>
                                <textarea id="reviewContentInput" name="reviewContent" rows="3" class="form-control" required></textarea>
                            </div>
                            
                            <button type="submit" class="btn btn-fatcat" style="font-size : 20px;">리뷰 등록</button>
                        </form>
                        <hr>
                        <div id="reviewList">
                            <strong style="font-size : 25px;">등록된 리뷰</strong>
                            <p  style="font-size : 20px;">... 리뷰 로딩 중 ...</p>
                        </div>
                    </div>
                `;
                
                // 'X' 버튼 클릭 시 닫기
                document.getElementById('closeDetail').onclick = () => {
                    detailPanel.classList.remove('show');
                    map.panTo(originalCenter || map.getCenter());
                    openedPlaceId = null;
                };

                fetchReviews(place.place_name, place.address_name || place.road_address_name);
                setupStarRating();
                document.getElementById('reviewForm').addEventListener('submit', function(e) {
                    e.preventDefault();
                    const formData = new FormData(this);
                    const reviewData = {
                        placeName: formData.get('placeName'),
                        address: formData.get('address'),
                        reviewContent: formData.get('reviewContent'),
                        rating: parseInt(formData.get('rating'))
                    };
                    submitReview(reviewData);
                });

                detailPanel.classList.add('show');
                if (!originalCenter) originalCenter = map.getCenter();
                map.panBy(-detailPanel.offsetWidth / 2, 0);
                openedPlaceId = place.id;
            });
            $placesList.appendChild(li);
        });


        renderPagination();
	
     		// 🔹 현재 페이지 마커만 화면에 보이도록 bounds 설정
        if (document.getElementById('map').style.display !== 'none' && pagePlaces.length > 0) {
            const bounds = new kakao.maps.LatLngBounds();
            pagePlaces.forEach(p => bounds.extend(new kakao.maps.LatLng(p.y, p.x)));
            map.setBounds(bounds, 50); 
        }
    }

    function renderPagination() {
        $pagination.innerHTML = '';
        const totalPages = Math.ceil(allPlaces.length / pageSize);
        for (let i = 1; i <= totalPages; i++) {
            const a = document.createElement('a');
            a.href = '#';
            a.textContent = i;
            if (i === currentPage) a.className = 'on';
            else a.addEventListener('click', e => {
                e.preventDefault();
                currentPage = i;
                renderList();
            });
            $pagination.appendChild(a);
        }
    }

    function showInfo(marker, title) {
        infowindow.setContent('<div style="padding:5px;font-size:13px;">' + title + '</div>');
        infowindow.open(map, marker);
    }

    function toggleListView() {
        const mapDiv = document.getElementById('map');
        const btn = document.getElementById('btn');
        const menuWrap = document.getElementById('menu_wrap');
        if (mapDiv.style.display !== 'none') {
            mapDiv.style.display = 'none';
            btn.innerText = '지도랑 같이 보기';
            $placesList.style.display = 'grid';
            $placesList.style.gridTemplateColumns = 'repeat(3,1fr)';
            $placesList.style.gap = '10px';
            pageSize = 15;
            currentPage = 1;
            menuWrap.style.flex = '1';
            renderList();
        } else {
            mapDiv.style.display = 'block';
            btn.innerText = '리스트만 보기';
            kakao.maps.event.trigger(map, 'resize');
            $placesList.style.display = 'block';
            $placesList.style.gridTemplateColumns = 'none';
            $placesList.style.gap = '0';
            pageSize = 7;
            currentPage = 1;
            menuWrap.style.flex = '0.5';
            kakao.maps.event.trigger(map, 'resize');
            renderList();
        }
    }

    function setupStarRating() {
        const starsDiv = document.getElementById('ratingStars');
        starsDiv.innerHTML = '★★★★★'.split('').map((star, i) => `<span class="star" data-rating="${i+1}">${star}</span>`).join('');
        const stars = starsDiv.querySelectorAll('.star');
        const ratingInput = document.getElementById('ratingInput');
        stars.forEach(star => {
            star.addEventListener('click', function() {
                const rating = this.dataset.rating;
                ratingInput.value = rating;
                stars.forEach(s => s.classList.toggle('selected', s.dataset.rating <= rating));
            });
        });
    }
    
    async function updateReview(vetReviewSeq, newContent, newRating) {
        try {
            const response = await fetch(`/api/vet-clinics/reviews/${vetReviewSeq}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reviewContent: newContent, rating: parseInt(newRating) })
            });
            if (response.ok) {
                alert('리뷰가 성공적으로 수정되었습니다.');
                fetchReviews(document.getElementById('placeNameInput').value, document.getElementById('addressInput').value);
            } else { 
                const errorText = await response.text();
                // 💡 HTTP 상태 코드 추가
                alert(`리뷰 수정에 실패했습니다: ${errorText} (상태코드: ${response.status})`); 
            }
        } catch (error) { alert('네트워크 오류로 리뷰 수정에 실패했습니다.'); }
    }

    async function deleteReview(vetReviewSeq) {

        if (!confirm('정말로 이 리뷰를 삭제하시겠습니까?')) return;
        try {
            const response = await fetch(`/api/vet-clinics/reviews/${vetReviewSeq}`, { method: 'DELETE' });
            if (response.ok) {
                alert('리뷰가 성공적으로 삭제되었습니다.');
                fetchReviews(document.getElementById('placeNameInput').value, document.getElementById('addressInput').value);
            } else { 
                 const errorText = await response.text();
                 // 💡 HTTP 상태 코드 추가
                 alert(`리뷰 삭제에 실패했습니다: ${errorText} (상태코드: ${response.status})`); 
            }
        } catch (error) { alert('네트워크 오류로 리뷰 삭제에 실패했습니다.'); }
    }
    
/* vetclinic_map.html 484줄 부근의 fetchReviews 함수를 아래 코드로 대체 */
    
    // ⭐ Helper 함수: 원본 수정/삭제 버튼을 생성하고 리스너를 붙여 반환
    function createOriginalActionDiv(vetReviewSeq, reviewContent, rating) {
        const actionDivId = `review-actions-${vetReviewSeq}`;
        const actionDivHTML = `
            <div id="${actionDivId}" class="review-actions d-flex justify-content-end" style="font-size : 20px; gap: 5px;"> 
                <button class="btn btn-outline-brown btn-sm edit-btn" style="font-size: 16px;">수정</button>
                <button class="btn btn-outline-danger btn-sm delete-btn" style="font-size: 16px;">삭제</button>
            </div>
        `;

        const parser = new DOMParser();
        const doc = parser.parseFromString(actionDivHTML, 'text/html');
        const actionDiv = doc.body.firstChild;

        // 원본 Edit/Delete 리스너를 다시 붙입니다.
        actionDiv.querySelector('.edit-btn').addEventListener('click', () => {
            handleUpdateReview(vetReviewSeq, reviewContent, rating);
        });
        actionDiv.querySelector('.delete-btn').addEventListener('click', () => {
            deleteReview(vetReviewSeq);
        });
        
        return actionDiv;
    }


    async function fetchReviews(placeName, address) {
        try {
            const params = new URLSearchParams({ placeName, address });
            const response = await fetch(`/api/vet-clinics/reviews?${params.toString()}`);
            const data = await response.json();

            const avgRatingEl = document.getElementById('avgRating');
            const reviewListEl = document.getElementById('reviewList');
            
            // ... (평점 표시 로직 생략) ...

            reviewListEl.innerHTML = `<strong style="font-size : 25px;">등록된 리뷰</strong>`;

            if (data.reviews && data.reviews.length > 0) {
                data.reviews.forEach(review => {
                    const isAuthor = LOGGED_IN_USER_SEQ && LOGGED_IN_USER_SEQ === review.userSeq;
                    const authorName = review.userName || '익명';
                    
                    const reviewItem = document.createElement('div');
                    reviewItem.id = `review-${review.vetReviewSeq}`;
                    reviewItem.innerHTML = `
                        <p class="review-meta" style="font-size : 20px; color:#555555;">작성자: ${authorName} | 별점: ${'★'.repeat(review.vetRating)}</strong> | 작성일자: ${review.createDate}</p>
                        <p class="review-content-text" style="font-size : 20px;">${review.vetReview}</p>
                        <hr>
                    `;
                    reviewListEl.appendChild(reviewItem);

                    if (isAuthor) {
                        // ⭐ Helper 함수를 사용하여 버튼 생성 및 리스너 연결
                        const actionDiv = createOriginalActionDiv(review.vetReviewSeq, review.vetReview, review.vetRating);
                        reviewItem.insertBefore(actionDiv, reviewItem.querySelector('hr'));
                    }
                });
            } else {
                reviewListEl.innerHTML += `<p  style="font-size : 20px;">등록된 리뷰가 없습니다.</p>`;
            }
        } catch (error) {
            console.error('리뷰 정보를 가져오는 데 실패했습니다.', error);
            document.getElementById('reviewList').innerHTML = `<p>리뷰 정보를 가져올 수 없습니다.</p>`;
        }
    }
    
    /* vetclinic_map.html 567줄 부근의 handleUpdateReview 함수를 아래 코드로 대체 */
    function handleUpdateReview(vetReviewSeq, reviewContent, rating) {
        const reviewItem = document.getElementById(`review-${vetReviewSeq}`);
        const existingForm = reviewItem.querySelector('.update-form');
        // ⭐ 기존 버튼 영역 ID를 통해 선택 (fetchReviews에서 ID 부여됨)
        const actionDiv = document.getElementById(`review-actions-${vetReviewSeq}`); 

        // Helper 함수: 버튼을 원본(수정/삭제)으로 복구하고 폼을 제거합니다.
        const revertAndCleanUp = () => {
            // 원본 버튼 영역을 재 생성하여 리스너까지 복구합니다.
            const originalActionDiv = createOriginalActionDiv(vetReviewSeq, reviewContent, rating);
            
            // Save/Cancel 상태의 버튼 영역을 원본으로 교체
            actionDiv.parentNode.replaceChild(originalActionDiv, actionDiv);
            
            // 폼 제거
            const currentForm = reviewItem.querySelector('.update-form');
            if (currentForm) currentForm.remove();
        };

        // 1. 이미 수정 폼이 열려있다면 닫고 종료 (Cancel 기능)
        if (existingForm) {
            existingForm.classList.remove('show');
            setTimeout(() => {
                revertAndCleanUp();
            }, 400);
            return;
        }
        
        // -----------------------------------------------------------
        // 2. 버튼 토글을 위한 준비 (리스너 제거 및 새 리스너 부착을 위해 버튼 복제)
        const editBtn = actionDiv.querySelector('.edit-btn');
        const deleteBtn = actionDiv.querySelector('.delete-btn');

        // 리스너를 안전하게 제거하기 위해 버튼 노드 복제 및 교체
        const newEditBtn = editBtn.cloneNode(true);
        const newDeleteBtn = deleteBtn.cloneNode(true);
        editBtn.parentNode.replaceChild(newEditBtn, editBtn);
        deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
        
        const saveBtn = newEditBtn;
        const cancelBtn = newDeleteBtn;

        // 외형 및 텍스트 변경: 수정 -> 저장, 삭제 -> 취소
        saveBtn.textContent = '저장';
        saveBtn.className = 'btn btn-outline-success btn-sm save-btn';
        cancelBtn.textContent = '취소';
        cancelBtn.className = 'btn btn-outline-secondary btn-sm cancel-btn';
        
        // -----------------------------------------------------------
        // 3. 수정 폼 생성 (버튼 제거)
        const updateForm = document.createElement('div');
        updateForm.className = 'update-form';
        updateForm.innerHTML = `
            <div class="form-group" style="font-size: 20px;">
                <label>별점:</label>
                <div class="star-rating update-stars">
                    <span class="star" data-rating="1">★</span>
                    <span class="star" data-rating="2">★</span>
                    <span class="star" data-rating="3">★</span>
                    <span class="star" data-rating="4">★</span>
                    <span class="star" data-rating="5">★</span>
                </div>
                <input type="hidden" class="update-rating-input" value="${rating}">
            </div>
            <div class="form-group">
                <label style="font-size: 20px;">내용:</label>
                <textarea class="update-content-input form-control" style="font-size: 20px;" rows="3">${reviewContent}</textarea>
            </div>
        `; 
        
        // 기존 버튼 영역(actionDiv) 바로 앞에 폼 삽입
        reviewItem.insertBefore(updateForm, actionDiv); 
        
        // -----------------------------------------------------------
        // ⭐ 4. 스크롤 및 폼 보이기
        setTimeout(() => {
            updateForm.classList.add('show');
            
            // 스크롤: 폼이 화면 중앙에 보이도록 block: 'center'로 설정하여 확실하게 이동
            updateForm.scrollIntoView({ behavior: 'smooth', block: 'center' }); 
        }, 50);

        // -----------------------------------------------------------
        // 5. 토글된 버튼에 저장/취소 리스너 부착
        
        // 저장 버튼 리스너
        saveBtn.addEventListener('click', () => {
            const newContent = updateForm.querySelector('.update-content-input').value;
            const newRating = updateForm.querySelector('.update-rating-input').value;
            updateReview(vetReviewSeq, newContent, newRating); // API 호출
            
            // 저장 후 폼 닫고 버튼 복구
            setTimeout(() => {
                revertAndCleanUp();
            }, 50); 
        });

        // 취소 버튼 리스너 (폼 닫고 버튼 복구)
        cancelBtn.addEventListener('click', () => {
            updateForm.classList.remove('show');
            setTimeout(() => {
                revertAndCleanUp();
            }, 400);
        });
        
        // -----------------------------------------------------------
        // 6. 별점 로직
        const updateStars = updateForm.querySelectorAll('.star-rating .star');
        const updateRatingInput = updateForm.querySelector('.update-rating-input');
        updateStars.forEach(star => {
            if (parseInt(star.dataset.rating) <= rating) star.classList.add('selected');
            star.addEventListener('click', function() {
                const newRating = parseInt(this.dataset.rating);
                updateRatingInput.value = newRating;
                updateStars.forEach(s => {
                    if (parseInt(s.dataset.rating) <= newRating) s.classList.add('selected');
                    else s.classList.remove('selected');
                });
            });
        });
    }
    
    async function submitReview(reviewData) {
        if (LOGGED_IN_USER_SEQ === null) {
            alert('리뷰 작성은 로그인 후 이용 가능합니다.');
            return;
        }
        try {
            const response = await fetch('/api/vet-clinics/reviews', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(reviewData)
            });
            if (response.ok) {
                alert('리뷰가 성공적으로 등록되었습니다.');
                document.getElementById('reviewContentInput').value = '';
                document.getElementById('ratingInput').value = '';
                document.querySelectorAll('#ratingStars .star').forEach(s => s.classList.remove('selected'));
                fetchReviews(reviewData.placeName, reviewData.address);
            } else { 
                const errorText = await response.text();
                alert(`리뷰 등록에 실패했습니다. (상태코드: ${response.status}): ${errorText}`); 
            }
        } catch (error) { 
            console.error(error);
            alert('네트워크 오류로 리뷰 등록에 실패했습니다.'); 
        }
    }
</script>
	</div>
</body>
</html>
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="utf-8">
<title>최종 수정본: 1:1 채팅 + CareSession + 리뷰 + UI 개선 (날짜 구분선 포함)</title>
<style>
/* ---------------------------------------------------------------------------------- */
/* 1. 기본 채팅 UI 스타일 */
/* ---------------------------------------------------------------------------------- */

@font-face {
	font-family: 'Juache';
	src:
		url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_one@1.0/BMJUA.woff')
		format('woff');
	font-weight: normal;
	font-display: swap;
}


body {
	font-family: 'Juache', sans-serif; 
	
	margin: 0;
	padding: 0;
	display: flex;
	flex-direction: column;
	height: 100vh;
}

#user-select {
	display: flex;
	justify-content: center;
	gap: 15px;
	padding: 10px;
	border-bottom: 1px solid #ddd;
	background: #fafafa;
}

/* 기본 입력 필드 스타일 및 폰트 적용 */
select, input, textarea {
	font-family: 'Juache', sans-serif;
	padding: 5px 10px;
	border-radius: 6px;
	border: 1px solid #ccc;
}

/* ---------------------------------------------------------------------------------- */
/* 플레이스홀더 폰트 적용 */
/* ---------------------------------------------------------------------------------- */
#message-input::placeholder,
#session-note::placeholder,
input::placeholder,
textarea::placeholder {
    font-family: 'Juache', sans-serif !important;
}

::-webkit-input-placeholder { /* Chrome, Safari */
    font-family: 'Juache', sans-serif !important;
}
:-moz-placeholder { /* Firefox 18- */
    font-family: 'Juache', sans-serif !important;
}
::-moz-placeholder { /* Firefox 19+ */
    font-family: 'Juache', sans-serif !important;
}
:-ms-input-placeholder { /* IE */
    font-family: 'Juache', sans-serif !important;
}
/* ---------------------------------------------------------------------------------- */


#chat-container {
	flex-grow: 1;
	display: flex;
	flex-direction: column;
	border: 1px solid #ddd;
	margin: 10px;
	border-radius: 8px;
	overflow: hidden;
	position: relative;
}

#message-area {
	flex-grow: 1;
	padding: 10px;
	overflow-y: auto;
	background: #f7f7f7;
	display: flex;
	flex-direction: column;
}

/* ✨ 날짜 구분선 스타일 ✨ */
.date-separator {
    text-align: center;
    margin: 15px 0; /* 위아래 간격 */
}

.date-separator span {
    font-size: 12px;
    color: #888;
    background: #e9e9e9; /* 연한 회색 배경 */
    padding: 4px 10px;
    border-radius: 12px; /* 둥근 모양 */
    font-weight: 500;
    font-family: 'Juache', sans-serif;
    display: inline-block; /* 배경이 텍스트 크기만큼만 채워지도록 */
}
/* ✨ 날짜 구분선 스타일 끝 ✨ */


.message-row {
	display: flex;
	margin-bottom: 10px;
	align-items: flex-end;
}

.message-row.sent {
	justify-content: flex-end;
}

.message-row.received {
	justify-content: flex-start;
}

.profile-placeholder {
	width: 40px;
	height: 40px;
	border-radius: 50%;
	background-color: #ccc;
	margin-right: 10px;
	align-self: flex-start;
	flex-shrink: 0;
	cursor: pointer;
}

.message-content-wrapper {
	display: flex;
	flex-direction: column;
	max-width: 70%;
}

.message-row.sent .message-content-wrapper {
	align-items: flex-end;
}

.message-row.received .message-content-wrapper {
	align-items: flex-start;
}

.user-nickname {
	font-size: 12px;
	color: #555;
	margin-bottom: 4px;
	cursor: pointer;
}

.message-row.sent .user-nickname {
	display: none;
}

.sent .message {
	background: #ebdecd;
	
}
.message {
	padding: 8px 12px;
	border-radius: 18px;
	max-width: 100%;
	word-wrap: break-word;
	position: relative;
}



.received .message {
	background: #fff;
}

.message-time {
	font-size: 10px;
	color: #555;
	margin-top: 2px;
	align-self: flex-end;
	white-space: nowrap;
}

.message-row.received .message-time {
	align-self: flex-start;
}

.care-request {
	background: #FFFACD;
	padding: 6px 10px;
	border-radius: 12px;
	margin-top: 4px;
}

.care-confirmed {
	background: #8FBC8F;
	padding: 6px 10px;
	border-radius: 12px;
	margin-top: 4px;
}

#input-area {
	display: flex;
	padding: 10px;
	border-top: 1px solid #ddd;
	gap: 10px;
}

#message-input {
	flex-grow: 1;
	padding: 8px;
	border-radius: 20px;
	border: 1px solid #ccc;
	outline: none;
}

/* 버튼에도 폰트, 커서 포인터 적용 */
 #send-button, #care-toggle {
 	font-family: 'Juache', sans-serif;
	background-color: #D2B48C;
	color: #fff;
	border-radius: 20px;
	padding: 6px 16px;
	border: none;
	font-weight: 500;
    cursor: pointer; /* 커서 포인터 추가 */
} 


#send-button:hover, #care-toggle:hover {
	background-color: #a38b6a; /* hover 시 조금 진하게 */
	color: #fff;
} 

/* ---------------------------------------------------------------------------------- */
/* 2. 돌봄 요청 폼 (CARE FORM) 스타일: 디자인 개선 및 라운드 값 적용 */
/* ---------------------------------------------------------------------------------- */

#care-form {
    display: none; /* 기본은 숨김 */
    padding: 15px; 
    border: 1px solid #e0e0e0; 
    border-radius: 12px; 
    margin: 10px; 
    background-color: #f7f9fb; /* 배경 박스 */
    flex-wrap: wrap; 
    gap: 10px; 
    flex-direction: row; 
    font-size: 14px; 
    line-height: 1.4;
    border-top: 1px solid #ddd; 
}

/* JS로 .active 클래스가 붙으면 폼이 보입니다. */
#care-form.active {
    display: flex;
}

/* 개별 입력 그룹 스타일 */
.care-form-group {
    flex: 1 1 calc(50% - 5px); 
    display: flex;
    flex-direction: column; 
}

/* 메모, 버튼 등 전체 너비 요소 */
.care-form-group.full-width {
    flex: 1 1 100%; 
}

/* 라벨 스타일 */
#care-form label {
    font-weight: bold;
    color: #555;
    margin-bottom: 3px;
}


/* 입력 필드 (input, textarea) 공통 스타일 - 라운드 값 적용 */
#care-form input[type="datetime-local"],
#care-form textarea {
    padding: 10px; 
    border: 1px solid #ccc;
    border-radius: 6px; 
    box-sizing: border-box; 
    margin-top: 4px; 
    width: 100%; 
    font-size: 14px;
    background-color: white; 
}

/* 메모장 줄 수 설정 */
#care-form textarea {
    resize: vertical; 
}

/* 예약 전송 버튼 스타일 */
#confirm-care {
	font-family: 'Juache', sans-serif;
    width: 100%; 
    padding: 10px; 
    border: none;
    border-radius: 20px; 
    font-weight: bold;
    cursor: pointer; /* 커서 포인터 유지 */
    background-color: #D2B48C;
    color: #fff;
    transition: background-color 0.3s;
}

#confirm-care:hover {
	background-color: #a38b6a;
}

/* 버튼 컨테이너 정렬 */
.button-container {
    display: flex;
    justify-content: flex-start;
}

/* ---------------------------------------------------------------------------------- */
/* 3. 리뷰 팝업 스타일 */
/* ---------------------------------------------------------------------------------- */
#review-popup {
	position: absolute;
	top: 0;
	right: 0;
	width: 350px;
	height: 100%;
	background: white;
	box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
	z-index: 100;
	transform: translateX(100%);
	transition: transform 0.3s ease-in-out;
	display: flex;
	flex-direction: column;
	padding: 15px;
	box-sizing: border-box;
	border-left: 1px solid #ddd;
	overflow-y: auto;
}

#review-popup.show {
	transform: translateX(0);
}

.popup-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 15px;
}

.popup-header button {
	background: none;
	border: none;
	font-size: 20px;
	cursor: pointer;
}

#review-rating-summary {
	text-align: center;
	padding: 10px 0;
	border-bottom: 1px solid #eee;
	margin-bottom: 15px;
}

#review-rating-summary h3 {
	margin: 0;
	font-size: 1.5em;
}

#review-rating-summary p {
	margin: 5px 0 0;
	color: #666;
}

.star-rating {
	color: gold;
	font-size: 1.2em;
}

/* [수정] 리뷰 등록 폼 스타일 - 배경 박스 추가 */
#review-form-area {
    padding: 15px; 
    margin-bottom: 20px; 
    background-color: #f7f9fb; /* 연한 회색 배경 */
    border-radius: 12px; /* 둥근 모서리 */
    border-top: none; /* 기존 border-top 제거 */
}

#review-form-area h4 {
	font-family: 'Juache', sans-serif;
	margin-top: 0;
	margin-bottom: 15px; /* 제목 아래 간격 추가 */
}

#review-form-area textarea {
	/* [수정] 입력 필드 라운드 값 적용 */
	border-radius: 6px; 
	width: 100%;
	margin-bottom: 10px;
	box-sizing: border-box;
	font-family: 'Juache', sans-serif; /* 명시적으로 폰트 적용 */
}

.rating-input {
	margin-bottom: 10px;
}

.rating-input span {
	font-size: 1.5em;
	cursor: pointer;
	color: #ccc;
}

.rating-input span.active {
	color: gold;
}

#submit-review-btn {
	width: 100%;
	padding: 10px; /* 버튼 높이 증가 */
	background: #D2B48C; 
	color: white;
	border: none;
	border-radius: 20px; 
	cursor: pointer; /* 커서 포인터 추가 */
	font-weight: 500;
	font-family: 'Juache', sans-serif; 
	transition: background-color 0.3s;
}

#submit-review-btn:hover {
	background: #a38b6a;
}

/* 리뷰 목록 스타일 */
#review-list {
	flex-grow: 1;
	overflow-y: auto;
	padding-right: 5px;
}

.review-item {
	/* 리뷰 내용에도 폰트 적용 */
	font-family: 'Juache', sans-serif;
	padding: 10px 0;
	border-bottom: 1px dotted #ddd;
	position: relative;
}
/* 리뷰 내용 래퍼는 항상 표시 (내용 유지 요청에 따라) */
.review-content-wrapper {
	display: block;
}

.review-item:last-child {
	border-bottom: none;
}

.review-header {
	display: flex;
	justify-content: space-between;
	font-size: 0.9em;
	color: #444;
	margin-bottom: 5px;
}

.review-body {
	font-size: 0.95em;
	color: #333;
	word-break: break-all;
}

.review-date {
	font-size: 0.8em;
	color: #999;
	margin-top: 5px;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

/* 수정/삭제 버튼 스타일 */
.review-actions button {
	font-size: 0.75em;
	padding: 3px 6px;
	margin-left: 5px;
	border: 1px solid #ccc;
	border-radius: 4px;
	cursor: pointer; /* 커서 포인터 추가 */
	background: #fff;
	font-family: 'Juache', sans-serif;
}

.review-actions button.edit {
	color: #007bff;
	border-color: #007bff;
}

.review-actions button.delete {
	color: #dc3545;
	border-color: #dc3545;
}

/* ---------------------------------------------------------------------------------- */
/* 4. 인라인 리뷰 수정 폼 스타일 (이미지 레이아웃에 맞게 조정) */
/* ---------------------------------------------------------------------------------- */
.edit-inline-form {
	padding: 10px 0 0 0;
	margin-top: 0px;
	margin-bottom: 5px;
	width: 100%;
	box-sizing: border-box;
	display: block;
	font-family: 'Juache', sans-serif;
}
/* 수정 폼 내부의 경계선 스타일 */
.edit-inline-form>div {
	margin-top: 10px;
	padding-top: 10px;
	border-top: 1px dashed #ccc;
}

.edit-inline-form h4 {
	margin: 5px 0 5px 0;
	font-size: 0.9em;
}

.edit-review-textarea {
	/* [수정] 입력 필드 라운드 값 적용 */
	border-radius: 6px; 
	width: 100%;
	box-sizing: border-box;
	margin-bottom: 10px;
	border: 1px solid #ccc; /* 테두리 추가 */
	padding: 5px;
	font-family: 'Juache', sans-serif;
}

.edit-inline-rating {
	margin-bottom: 5px;
}

.edit-inline-rating span {
	font-size: 1.5em;
	cursor: pointer;
	color: #ccc;
}

.edit-inline-rating span.active {
	color: gold;
}

.edit-actions button {
	font-size: 0.8em !important;
	padding: 5px 10px !important;
	font-family: 'Juache', sans-serif !important;
    cursor: pointer !important; /* 커서 포인터 추가 */
}

.edit-actions button.save {
	/* [수정] 색상 통일 */
	background: #D2B48C; 
	color: white;
	border: none;
	border-radius: 4px;
}
.edit-actions button.save:hover {
	background: #a38b6a;
}


.edit-actions button.cancel {
	background: #dc3545;
	color: white;
	border: none;
	border-radius: 4px;
	margin-left: 5px;
}
</style>
<script
	src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script
	src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>

	<div id="user-select">
		<label>보내는 사람: <select id="sender-select">
				<option value="">선택하세요</option>
				<option value="1" data-username="김유정">User 1</option>
				<option value="2" data-username="유정">User 2</option>
				<option value="3" data-username="관리왕">User 3</option>
		</select>
		</label> <label>받는 사람: <select id="receiver-select">
				<option value="">선택하세요</option>
				<option value="1" data-username="김유정">User 1</option>
				<option value="2" data-username="유정">User 2</option>
				<option value="3" data-username="관리왕">User 3</option>
		</select>
		</label>
	</div>

	<div id="chat-container">
		<div id="message-area"></div>
		<div id="input-area">
			<input type="text" id="message-input" placeholder="메시지를 입력하세요...">
			<button id="send-button" class="btn btn-fatcat" >전송</button>
			<button id="care-toggle" class="btn btn-fatcat">돌봄 예약</button>
		</div>
        
		<div id="care-form">
			<div class="care-form-group">
				<label for="start-date">시작일:</label>
				<input type="datetime-local" id="start-date">
			</div>
			<div class="care-form-group">
				<label for="end-date">종료일:</label>
				<input type="datetime-local" id="end-date">
			</div>
			
			<div class="care-form-group" style="display: none;">
				<input type="hidden" id="session-status" name="sessionStatus" value="REQUESTED">
			</div>
			
			<div class="care-form-group full-width">
				<label for="session-note">메모:</label>
				<textarea id="session-note" rows="3" placeholder="메모를 입력하세요"></textarea>
			</div>
			<div class="care-form-group full-width button-container">
				<button id="confirm-care" class="btn btn-fatcat">예약 전송</button>
			</div>
		</div>
		<div id="review-popup">
			<div class="popup-header">
				<h2 id="review-target-name"></h2>
				<button onclick="closeReviewPopup()">×</button>
			</div>

			<div id="review-rating-summary">
				<h3 id="avg-rating"></h3>
				<p id="total-reviews"></p>
			</div>

			<div id="review-form-area">
				<h4>리뷰 등록</h4>
				<div class="rating-input" id="new-rating">
					<span data-rating="1">★</span> <span data-rating="2">★</span> <span
						data-rating="3">★</span> <span data-rating="4">★</span> <span
						data-rating="5">★</span>
				</div>
				<textarea id="new-review-text" rows="3" placeholder="리뷰 내용을 입력하세요."></textarea>
				<button id="submit-review-btn">리뷰 작성</button>
			</div>

			<h4>리뷰 목록</h4>
			<div id="review-list"></div>
		</div>
	</div>
<script>
let senderId = null;
let receiverId = null;
let chatRoomId = null;
let stompClient = null;
let targetUserSeqForReview = null; 
let currentRating = 0; 
let currentEditReviewId = null; 
let currentEditRating = 0; 
let currentEditForm = null; 
let userNames = {}; 

// ✨ 날짜 구분선 로직을 위한 전역 변수 추가 ✨
let lastDisplayedDate = null; 

const messageArea = document.getElementById('message-area');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const careToggle = document.getElementById('care-toggle');
const careForm = document.getElementById('care-form');
const startDateInput = document.getElementById('start-date');
const endDateInput = document.getElementById('end-date');
const confirmCare = document.getElementById('confirm-care');


// --------------------------------------------------------
// 초기화 및 이벤트 리스너
// --------------------------------------------------------

window.onload = function() {
    const senderSelect = document.getElementById('sender-select');
    const receiverSelect = document.getElementById('receiver-select');

    function extractUserNames(selectElement) {
        Array.from(selectElement.options).forEach(option => {
            if (option.value) {
                userNames[option.value] = option.dataset.username || `User ${option.value}`;
            }
        });
    }
    extractUserNames(senderSelect);
    extractUserNames(receiverSelect);


    senderSelect.addEventListener('change', async (e) => {
        senderId = parseInt(e.target.value);
        if(document.getElementById('review-popup').classList.contains('show') && targetUserSeqForReview) {
            fetchReviews(targetUserSeqForReview);
        }
        if (senderId && receiverId) await initChatRoom();
    });
    
    receiverSelect.addEventListener('change', async (e) => {
        receiverId = parseInt(e.target.value);
        if (senderId && receiverId) await initChatRoom();
    });

    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') sendMessage();
    });

    // ✨ 돌봄 예약 토글 로직 수정 (더블클릭 문제 해결) ✨
    careToggle.addEventListener('click', () => {
    	 
    	        // 클래스 토글: 폼의 'active' 클래스를 추가/제거합니다.
    	        careForm.classList.toggle('active');
    	        
    	        // 버튼 텍스트 변경
    	        if (careForm.classList.contains('active')) {
    	            careToggle.textContent = '예약 취소';
    	        } else {
    	            careToggle.textContent = '돌봄 예약';
    	        
    	        }
    });

    confirmCare.addEventListener('click', sendCareRequest);

    document.querySelectorAll('#new-rating span').forEach(star => {
        star.addEventListener('click', () => {
            currentRating = parseInt(star.dataset.rating);
            updateStarRating(currentRating, document.getElementById('new-rating'));
        });
    });

    document.getElementById('submit-review-btn').addEventListener('click', submitReview);
};

// --------------------------------------------------------
// 채팅 및 돌봄 요청 로직 
// --------------------------------------------------------

function sendCareRequest() {
    const start = startDateInput.value;
    const end = endDateInput.value;
    if (!start || !end) return alert("날짜를 선택하세요.");

    const startWithSeconds = start + ':00';
    const endWithSeconds = end + ':00';

    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: receiverId,
        type: "CARE_REQUEST",
        startDate: startWithSeconds,
        endDate: endWithSeconds,
        status: 'REQUESTED',
        note: document.getElementById('session-note').value,
        content: `돌봄 요청: ${start} ~ ${end}`
    };

    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));

    // 클래스 토글을 사용하도록 변경 (폼을 닫음)
    careForm.classList.remove('active');
    careToggle.textContent = '돌봄 예약';
    
    startDateInput.value = '';
    endDateInput.value = '';
    document.getElementById('session-note').value = '';
}

function confirmCareRequest(sessionId, senderIdFromMsg) {
    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: senderIdFromMsg,
        type: "CARE_CONFIRM",
        sessionId: sessionId,
        content: `✅ 돌봄 예약이 확정되었습니다.`
    };
    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));
}

function updateCareRequestUI(sessionId, confirmedTime) {
    const requestElements = document.querySelectorAll(`[data-session-id="${sessionId}"]`);
    
    const confirmedDate = new Date(confirmedTime.replace(' ', 'T'));
    const formattedDate = `${confirmedDate.getFullYear()}-${(confirmedDate.getMonth() + 1).toString().padStart(2, '0')}-${confirmedDate.getDate().toString().padStart(2, '0')}`;
    const hours = confirmedDate.getHours();
    const minutes = confirmedDate.getMinutes().toString().padStart(2,'0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const hour12 = hours % 12 === 0 ? 12 : hours % 12;
    const formattedTime = `${formattedDate} ${ampm} ${hour12}:${minutes}`;

    requestElements.forEach(element => {
        const confirmButton = element.querySelector('.confirm-btn');
        if (confirmButton) {
            confirmButton.remove();
        }
        
        const existingStatusSpan = element.querySelector('.care-status');
        if (existingStatusSpan) {
            existingStatusSpan.innerHTML = `[✅ 확정됨 - ${formattedTime}]`;
        } else {
            const confirmedSpan = document.createElement('span');
            confirmedSpan.classList.add('care-status'); 
            confirmedSpan.style.color = 'green';
            confirmedSpan.style.fontWeight = 'bold';
            confirmedSpan.innerText = `[✅ 확정됨 - ${formattedTime}]`;
            element.querySelector('.care-request').appendChild(confirmedSpan);
        }
    });
}

async function initChatRoom() {
    if (!senderId || !receiverId) return;
    if (stompClient && stompClient.connected) stompClient.disconnect();

    try {
        const res = await fetch(`/api/chat/room?sender=${senderId}&receiver=${receiverId}`);
        const data = await res.json();
        chatRoomId = data.chatSeq;

        const histRes = await fetch(`/api/chat/history?roomId=${chatRoomId}`);
        const history = await histRes.json();
        
        // ✨ 날짜 구분선 초기화 로직 추가 ✨
        lastDisplayedDate = null; 
        
        displayChatHistory(history);

        connectWebSocket();
    } catch (error) {
        console.error("채팅방 초기화 오류:", error);
    }
}

function connectWebSocket() {
    const socket = new SockJS('/ws');
    stompClient = Stomp.over(socket);

    stompClient.connect({}, () => {
        stompClient.subscribe(`/topic/chat/${chatRoomId}`, (message) => {
            const chatMessage = JSON.parse(message.body);
            displayMessage(chatMessage);
            
            if (chatMessage.type === "CARE_CONFIRM") {
                updateCareRequestUI(chatMessage.sessionId, chatMessage.confirmedTime);
            }
        });
    }, (error) => console.error("Connection error: ", error));
}

function sendMessage() {
    if (!stompClient || !stompClient.connected) return;
    if (!messageInput.value.trim()) return;

    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: receiverId,
        type: "CHAT",
        content: messageInput.value.trim()
    };

    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));
    messageInput.value = '';
}

// --------------------------------------------------------
// 메시지 표시 
// --------------------------------------------------------

// ✨ 날짜를 'YYYY년 M월 D일' 형식으로 포맷하는 함수 (구분선용) ✨
function formatDateForSeparator(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString.replace(' ', 'T'));
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${year}년 ${month}월 ${day}일`; 
}

// ✨ 날짜 비교를 위한 'YYYY-MM-DD' 형식 함수 (비교용) ✨
function getDateString(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString.replace(' ', 'T'));
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
}


function formatDateTime(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString.replace(' ', 'T'));
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}`;
}


function displayMessage(chatMessage) {
    // ✨ 날짜 구분선 로직 추가 시작 ✨
    const currentMessageDateTimeStr = chatMessage.timestamp || new Date().toISOString().replace('T', ' ').substring(0, 19);
    
    // 현재 메시지의 날짜 (YYYY-MM-DD)
    const currentMessageDate = getDateString(currentMessageDateTimeStr); 
    
    if (currentMessageDate !== lastDisplayedDate) {
        // 날짜가 바뀌었으면 구분선 추가
        const separatorDiv = document.createElement('div');
        separatorDiv.classList.add('date-separator');
        
        const dateSpan = document.createElement('span');
        // 'YYYY년 M월 D일' 형식으로 표시
        dateSpan.textContent = formatDateForSeparator(currentMessageDateTimeStr); 
        
        separatorDiv.appendChild(dateSpan);
        messageArea.appendChild(separatorDiv);
        
        // 마지막 날짜 업데이트
        lastDisplayedDate = currentMessageDate;
    }
    // ✨ 날짜 구분선 로직 추가 끝 ✨
    
    const isSent = chatMessage.senderId === senderId;
    const senderIdForPopup = chatMessage.senderId; 

    const senderName = userNames[chatMessage.senderId] || `User ${chatMessage.senderId}`;
    
    const messageRow = document.createElement('div');
    messageRow.classList.add('message-row');
    messageRow.classList.add(isSent ? 'sent' : 'received');
    
    const timeToFormat = chatMessage.timestamp ? new Date(chatMessage.timestamp.replace(' ', 'T')) : new Date();
    const hours = timeToFormat.getHours();
    const minutes = timeToFormat.getMinutes().toString().padStart(2,'0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const hour12 = hours % 12 === 0 ? 12 : hours % 12;
    const timeString = `${ampm} ${hour12}:${minutes}`;
    
    if (!isSent) {
        const profilePlaceholder = document.createElement('div');
        profilePlaceholder.classList.add('profile-placeholder');
        profilePlaceholder.addEventListener('click', () => openReviewPopup(senderIdForPopup));
        messageRow.appendChild(profilePlaceholder);
    }

    const contentWrapper = document.createElement('div');
    contentWrapper.classList.add('message-content-wrapper');

    if (!isSent) {
        const nameDiv = document.createElement('div');
        nameDiv.classList.add('user-nickname'); 
        nameDiv.innerText = senderName; 
        nameDiv.addEventListener('click', () => openReviewPopup(senderIdForPopup));
        contentWrapper.appendChild(nameDiv);
    }

    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');

    if (chatMessage.type === "CARE_REQUEST") {
        const careDiv = document.createElement('div');
        careDiv.setAttribute('data-session-id', chatMessage.sessionId || -1); 
        careDiv.classList.add('care-request');

        const status = chatMessage.status || 'REQUESTED';
        const sessionId = chatMessage.sessionId || -1;
        const isReceiver = chatMessage.senderId !== senderId;

        let confirmButtonHtml = '';
        let statusDisplay = '';

        if (status === 'REQUESTED' && isReceiver) {
            confirmButtonHtml = `<button class="confirm-btn" data-session-id="${sessionId}" data-sender-id="${chatMessage.senderId}">확정</button>`;
        } else if (status === 'CONFIRMED') {
            const formattedConfirmTime = chatMessage.confirmedTime ? 
                formatDateTime(chatMessage.confirmedTime) : 
                '시간 정보 없음';
            statusDisplay = `<span class="care-status" style="color: green; font-weight: bold;">[✅ 확정됨 - ${formattedConfirmTime}]</span>`;
        } else if (status === 'CANCELLED') {
            statusDisplay = `<span class="care-status" style="color: red; font-weight: bold;">[❌ 취소됨]</span>`;
        }
        
        const formattedStartDate = formatDateTime(chatMessage.startDate);
        const formattedEndDate = formatDateTime(chatMessage.endDate);


        careDiv.innerHTML = `
            <div style="font-weight: bold;">${chatMessage.content}</div>
            <div style="font-size: 0.9em;">기간: ${formattedStartDate} ~ ${formattedEndDate}</div>
            <div style="font-size: 0.9em;">메모: ${chatMessage.note || '없음'}</div>
            ${statusDisplay}
            ${confirmButtonHtml}
        `;
        messageDiv.appendChild(careDiv);

        if (status === 'REQUESTED' && isReceiver) {
            const confirmButton = careDiv.querySelector('.confirm-btn');
            if (confirmButton) {
                confirmButton.addEventListener('click', (event) => {
                    const session_Id = parseInt(event.target.dataset.sessionId);
                    const sender_Id = parseInt(event.target.dataset.senderId);
                    if (session_Id !== -1) {
                        confirmCareRequest(session_Id, sender_Id);

                        const tempConfirmedTime = new Date().toISOString().replace('T', ' ').substring(0, 19);
                        updateCareRequestUI(session_Id, tempConfirmedTime);
                    }
                });
            }
        }

    } else if (chatMessage.type === "CARE_CONFIRM") {
        messageDiv.classList.add('care-confirmed');
        messageDiv.innerText = chatMessage.content;
    } else {
        messageDiv.innerText = chatMessage.content;
    }
    
    contentWrapper.appendChild(messageDiv);
    
    const timeDiv = document.createElement('div');
    timeDiv.classList.add('message-time');
    timeDiv.innerText = timeString;
    contentWrapper.appendChild(timeDiv);

    messageRow.appendChild(contentWrapper);

    messageArea.appendChild(messageRow);
    messageArea.scrollTop = messageArea.scrollHeight;
}

function displayChatHistory(history) {
    messageArea.innerHTML = '';
    if (history && Array.isArray(history)) {
        // 메시지 기록은 항상 시간 순서대로 정렬되어 있어야 합니다.
        history.forEach(msg => displayMessage(msg)); 
    }
}


// --------------------------------------------------------
// 리뷰 팝업 및 로직 
// --------------------------------------------------------

function openReviewPopup(targetSeq) {
    if (!targetSeq || targetSeq === senderId) {
        alert("본인에 대한 리뷰는 등록하거나 확인할 수 없습니다.");
        return;
    }
    
    if (currentEditForm) {
        cancelEdit();
    }

    targetUserSeqForReview = targetSeq;
    const targetName = userNames[targetSeq] || `User ${targetSeq}`;

    document.getElementById('review-target-name').innerText = `${targetName} 님 리뷰`;
    document.getElementById('review-popup').classList.add('show');

    fetchReviews(targetSeq);
}

function closeReviewPopup() {
    document.getElementById('review-popup').classList.remove('show');
    targetUserSeqForReview = null;
    
    currentRating = 0;
    document.getElementById('new-review-text').value = '';
    updateStarRating(0, document.getElementById('new-rating'));

    if (currentEditForm) {
        cancelEdit();
    }
}

async function fetchReviews(targetSeq) {
    const listArea = document.getElementById('review-list');
    const avgRatingElem = document.getElementById('avg-rating');
    const totalReviewsElem = document.getElementById('total-reviews');
    listArea.innerHTML = '불러오는 중...';

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch(`/api/care-reviews?targetUserSeq=${targetSeq}`);
        if (!response.ok) throw new Error('Failed to fetch reviews');
        
        const reviews = await response.json();
        listArea.innerHTML = '';
        
        let totalRating = 0;
        
        if (reviews.length === 0) {
            listArea.innerHTML = '<p style="text-align: center; color: #999;">등록된 리뷰가 없습니다.</p>';
            avgRatingElem.innerHTML = '평점: <span class="star-rating">0.0</span>';
            totalReviewsElem.innerText = '총 0개의 리뷰';
            return;
        }

        reviews.forEach(review => {
            totalRating += review.careRating;
            listArea.appendChild(createReviewItem(review));
        });

        const average = (totalRating / reviews.length).toFixed(1);
        const starHtml = '★'.repeat(Math.round(average)) + '☆'.repeat(5 - Math.round(average));
        
        avgRatingElem.innerHTML = `평점: <span class="star-rating">${average}</span> (${starHtml})`;
        totalReviewsElem.innerText = `총 ${reviews.length}개의 리뷰`;

    } catch (error) {
        console.error("리뷰 로드 오류:", error);
        listArea.innerHTML = '<p style="color: red;">리뷰를 불러오는 중 오류가 발생했습니다.</p>';
        avgRatingElem.innerHTML = '평점: <span class="star-rating">--</span>';
        totalReviewsElem.innerText = '총 --개의 리뷰';
    }
}

/**
 * 리뷰 아이템 DOM 요소를 생성합니다. 
 */
function createReviewItem(review) {
    const item = document.createElement('div');
    item.classList.add('review-item');
    
    const starHtml = '★'.repeat(review.careRating) + '☆'.repeat(5 - review.careRating);
    const date = new Date(review.createDate);
    const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;

    // 현재 로그인된 사용자가 리뷰 작성자인 경우에만 수정/삭제 버튼 표시
    let actionButtons = '';
    if (review.authorUserSeq === senderId) { 
        actionButtons = `
            <div class="review-actions">
                <button class="edit" onclick="editReview(${review.reviewSeq}, '${review.careReview.replace(/'/g, "\\'")}', ${review.careRating})">수정</button>
                <button class="delete" onclick="deleteReview(${review.reviewSeq})">삭제</button>
            </div>
        `;
    }


    item.innerHTML = `
        <div class="review-content-wrapper">
            <div class="review-header">
                <span>${review.authorNickname}</span>
                <span class="star-rating">${starHtml}</span>
            </div>
            <div class="review-body">${review.careReview}</div>
            <div class="review-date">
                <span>${dateString}</span>
                ${actionButtons}
            </div>
        </div>
    `;
    item.id = `review-item-${review.reviewSeq}`;

    return item;
}

function updateStarRating(rating, container) {
    container.querySelectorAll('span').forEach(star => {
        if (parseInt(star.dataset.rating) <= rating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
}

async function submitReview() {
    const reviewText = document.getElementById('new-review-text').value.trim();

    if (currentRating === 0) {
        return alert("별점을 선택해주세요.");
    }
    if (reviewText.length < 5) {
        return alert("리뷰 내용을 5자 이상 입력해주세요.");
    }
    if (!targetUserSeqForReview || targetUserSeqForReview === senderId) {
        return alert("리뷰 대상을 확인할 수 없습니다.");
    }
    if (!senderId) {
        return alert("리뷰를 작성할 '보내는 사람'을 선택해주세요. (API 호출에 필요)");
    }

    const requestBody = {
        authorUserSeq: senderId, 
        targetUserSeq: targetUserSeqForReview,
        careReview: reviewText,
        careRating: currentRating,
        targetRole: "provider" 
    };

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch('/api/care-reviews', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 등록에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 등록되었습니다!");
        
        currentRating = 0;
        document.getElementById('new-review-text').value = '';
        updateStarRating(0, document.getElementById('new-rating'));

        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 등록 오류:", error);
        alert(error.message || "리뷰 등록 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    }
}

/**
 * ⭐ 인라인 수정 폼을 생성하고 해당 리뷰 밑에 표시합니다. (원본 내용 유지)
 */
function editReview(reviewId, content, rating) {
    // 이미 다른 폼이 열려 있다면 닫습니다.
    if (currentEditForm) {
        cancelEdit();
    }
    
    const reviewItem = document.getElementById(`review-item-${reviewId}`);
    if (!reviewItem) return;

    currentEditReviewId = reviewId;
    currentEditRating = rating;

    // ⭐ 버튼 일시적으로 숨기기
    const actions = reviewItem.querySelector('.review-actions');
    if (actions) actions.style.visibility = 'hidden'; 
    
    // 폼 내용 (이미지 모양과 일치하도록)
    const starHtml = `
        <div class="rating-input edit-inline-rating">
            <span data-rating="1">★</span>
            <span data-rating="2">★</span>
            <span data-rating="3">★</span>
            <span data-rating="4">★</span>
            <span data-rating="5">★</span>
        </div>
    `;
    
    const formHtml = document.createElement('div');
    formHtml.classList.add('edit-inline-form');
    // ⭐ div로 감싸고 border-top 스타일을 적용하여 분리된 느낌 연출
    formHtml.innerHTML = `
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px dashed #ccc;">
            <h4>별점:</h4>
            ${starHtml}
            <h4>내용:</h4>
            <textarea class="edit-review-textarea" rows="3">${content}</textarea>
            <div class="edit-actions" style="margin-top: 5px; text-align: right;">
                <button class="save" onclick="saveEditReview()">저장</button>
                <button class="cancel" onclick="cancelEdit()">취소</button>
            </div>
        </div>
    `;

    // ⭐ 기존 리뷰 내용 바로 밑에 수정 폼 추가
    reviewItem.appendChild(formHtml);
    currentEditForm = formHtml;
    
    // 별점 UI 설정
    const starContainer = formHtml.querySelector('.edit-inline-rating');
    updateStarRating(rating, starContainer); 

    starContainer.querySelectorAll('span').forEach(star => {
        star.addEventListener('click', () => {
            currentEditRating = parseInt(star.dataset.rating);
            updateStarRating(currentEditRating, starContainer);
        });
    });

    // 스크롤 이동
    const reviewList = document.getElementById('review-list');
    const itemOffset = reviewItem.offsetTop;
    const listHeight = reviewList.clientHeight;
    // 수정 폼이 중앙에서 약간 위에 오도록 스크롤 위치 조정
    reviewList.scrollTop = itemOffset - (listHeight / 4);
}


/**
 * ⭐ 수정 폼을 닫고 버튼을 복원합니다.
 */
function cancelEdit() {
    if (!currentEditReviewId || !currentEditForm) return;

    const reviewItem = document.getElementById(`review-item-${currentEditReviewId}`);
    
    currentEditForm.remove();

    // ⭐ 버튼 다시 표시
    if (reviewItem) {
        const actions = reviewItem.querySelector('.review-actions');
        if (actions) actions.style.visibility = 'visible';
    }
    
    currentEditReviewId = null;
    currentEditRating = 0;
    currentEditForm = null;
}


async function saveEditReview() {
    if (!currentEditReviewId || !currentEditForm) return alert("수정할 리뷰를 찾을 수 없습니다.");
    if (!senderId) return alert("'보내는 사람'을 선택해야 수정이 가능합니다. (API 호출에 필요)"); 

    const editedText = currentEditForm.querySelector('.edit-review-textarea').value.trim();

    if (currentEditRating === 0) {
        return alert("별점을 선택해주세요.");
    }
    if (editedText.length < 5) {
        return alert("리뷰 내용을 5자 이상 입력해주세요.");
    }
    
    const requestBody = {
        authorUserSeq: senderId, 
        targetUserSeq: targetUserSeqForReview, 
        careReview: editedText,
        careRating: currentEditRating,
        targetRole: "provider" 
    };

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch(`/api/care-reviews/${currentEditReviewId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 수정에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 수정되었습니다!");
        
        cancelEdit(); 
        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 수정 오류:", error);
        alert(error.message || "리뷰 수정 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    }
}


async function deleteReview(reviewId) {
    if (!senderId) return alert("'보내는 사람'을 선택해야 삭제가 가능합니다. (API 호출에 필요)"); 
    if (!confirm("정말로 이 리뷰를 삭제하시겠습니까?")) return;

    if (currentEditReviewId === reviewId) {
        cancelEdit();
    }

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch(`/api/care-reviews/${reviewId}?authorUserSeq=${senderId}`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 삭제에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 삭제되었습니다!");
        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 삭제 오류:", error);
        alert(error.message || "리뷰 삭제 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    }
}
</script>
</body>
</html>
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="utf-8">
<title>최종 수정본: 1:1 채팅 + CareSession + 리뷰 + UI 개선 (날짜 구분선 포함)</title>
<style>
.profile-image {
	margin-top: 5px; /* 닉네임과의 간격 조절 (선택 사항) */
	width: 40px; /* 크기 조절 */
	height: 40px; /* 크기 조절 */
	border-radius: 50%; /* 원형 */
	margin-right: 8px; /* 메시지 버블과의 간격 */
	align-self: flex-start; /* 메시지 row의 시작점에 정렬 */
	flex-shrink: 0;
	object-fit: cover; /* 이미지가 잘리지 않고 꽉 차게 */
	border: 1px solid #eee; /* 테두리 (선택 사항) */
	cursor: pointer;
}

/* 닉네임과 이미지가 정렬되도록 받은 메시지 스타일 조정 (선택 사항) */
.message-row.received {
    /* 기존: justify-content: flex-start; */
	align-items: flex-start; /* 닉네임과 이미지를 맨 위에 정렬 */
}



.sent .message.tail::after {
    content: '';
    position: absolute;
    bottom: 0; /* 메시지 박스 하단에 위치 */
    right: -7px; /* 메시지 박스 바깥쪽 오른쪽으로 빼냅니다. */
    width: 0;
    height: 0;
    z-index: 1;
    
    /* 꼬리 삼각형 모양 만들기 */
    border: 9px solid transparent; /* 꼬리 크기 조절 */
    border-radius : 2px;
    border-left-color: #ebdecd; /* 꼬리가 메시지 배경색과 동일하게 보입니다. */
    border-bottom-color: #ebdecd;
    
      
    /* 꼬리를 둥글고 휘어지게 만드는 핵심 속성 */
    border-bottom-right-radius: 30px; /* 꼬리의 끝을 둥글게 */
    border-bottom-left-radius: 80%; /* 꼬리의 몸통 부분을 곡선으로 만듦 */
    
    /* 꼬리가 뾰족한 삼각형이 아닌 둥근 모양처럼 보이도록 회전 */
    transform: rotate(6deg); /* 원하는 만큼 회전하여 휘어짐 정도 조정 */
    
   
}


/* ---------------------------------------------------------------------------------- */
/* 2. 받은 메시지 (왼쪽 아래 꼬리) */
/* ---------------------------------------------------------------------------------- */
.received .message.tail::after {
    content: '';
    position: absolute;
    bottom: 0; /* 메시지 박스 하단에 위치 */
    left: -10px; /* 메시지 박스 바깥쪽 오른쪽으로 빼냅니다. */
    width: 0;
    height: 0;
    z-index: 1;
    
    /* 꼬리 삼각형 모양 만들기 */
    border: 9px solid transparent; /* 꼬리 크기 조절 */
    border-radius : 2px;
    border-left-color: #ffffff; /* 꼬리가 메시지 배경색과 동일하게 보입니다. */
    border-bottom-color: #ffffff;
    
      
    /* 꼬리를 둥글고 휘어지게 만드는 핵심 속성 */
    border-bottom-right-radius: 30px; /* 꼬리의 끝을 둥글게 */
    border-bottom-left-radius: 80%; /* 꼬리의 몸통 부분을 곡선으로 만듦 */
    
    /* 꼬리가 뾰족한 삼각형이 아닌 둥근 모양처럼 보이도록 회전 */
    transform:rotateY(186deg); /* 원하는 만큼 회전하여 휘어짐 정도 조정 */
    
}
/* ---------------------------------------------------------------------------------- */
/* 1. 기본 채팅 UI 스타일 */
/* ---------------------------------------------------------------------------------- */

@font-face {
	font-family: 'Juache';
	src:
		url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_one@1.0/BMJUA.woff')
		format('woff');
	font-weight: normal;
	font-display: swap;
}


body {
	
	font-family: 'Juache', sans-serif; 
	font-size:16px;
	margin: 0;
	padding: 0;
	display: flex;
	flex-direction: column;
	height: 100vh;
}

#user-select {
	display: flex;
	justify-content: center;
	gap: 15px;
	padding: 10px;
	border-bottom: 1px solid #ddd;
	background: #fafafa;
}

/* 기본 입력 필드 스타일 및 폰트 적용 */
select, input, textarea {
	font-family: 'Juache', sans-serif;
	font-size:16px;
	padding: 5px 10px;
	border-radius: 6px;
	border: 1px solid #ccc;
}

/* ---------------------------------------------------------------------------------- */
/* 플레이스홀더 폰트 적용 */
/* ---------------------------------------------------------------------------------- */
#message-input::placeholder,
#session-note::placeholder,
input::placeholder,
textarea::placeholder {
    font-family: 'Juache', sans-serif !important;
}

::-webkit-input-placeholder { /* Chrome, Safari */
    font-family: 'Juache', sans-serif !important;
}
:-moz-placeholder { /* Firefox 18- */
    font-family: 'Juache', sans-serif !important;
}
::-moz-placeholder { /* Firefox 19+ */
    font-family: 'Juache', sans-serif !important;
}
:-ms-input-placeholder { /* IE */
    font-family: 'Juache', sans-serif !important;
}
/* ---------------------------------------------------------------------------------- */


#chat-container {
	flex-grow: 1;
	display: flex;
	flex-direction: column;
	border: 1px solid #ddd;
	margin: 10px;
	border-radius: 8px;
	overflow: hidden;
	position: relative;
}

#message-area {
	flex-grow: 1;
	padding: 10px;
	overflow-y: auto;
	background: #f7f7f7;
	display: flex;
	flex-direction: column;
	
}

/* ✨ 날짜 구분선 스타일 ✨ */
.date-separator {
    text-align: center;
    margin: 15px 0; /* 위아래 간격 */
}

.date-separator span {
    font-size: 16px;
    color: #888;
    background: #e9e9e9; /* 연한 회색 배경 */
    padding: 4px 10px;
    border-radius: 12px; /* 둥근 모양 */
    font-weight: 500;
    font-family: 'Juache', sans-serif;
    display: inline-block; /* 배경이 텍스트 크기만큼만 채워지도록 */
}
/* ✨ 날짜 구분선 스타일 끝 ✨ */


.message-row {
	display: flex;
	margin-bottom: 10px;
	align-items: flex-end;
}

.message-row.sent {
	justify-content: flex-end;
}

.message-row.received {
	justify-content: flex-start;
}

.profile-placeholder {
	margin-top: 15px;
	width: 50px;
	height: 50px;
	border-radius: 50%;
	background-color: #ccc;
	margin-right: 10px;
	align-self: flex-start;
	flex-shrink: 0;
	cursor: pointer;
	
}

.message-content-wrapper {
	display: flex;
	flex-direction: column;
	max-width: 70%;
}

.message-row.sent .message-content-wrapper {
	align-items: flex-end;
}

.message-row.received .message-content-wrapper {
	align-items: flex-start;
}

.user-nickname {
	font-size: 15px;
	color: #555;
	margin-bottom: 4px;
	cursor: pointer;
}

.message-row.sent .user-nickname {
	display: none;
}

.sent .message {
	background: #ebdecd;
	
}
.message {
	padding: 8px 12px;
	border-radius: 18px;
	max-width: 100%;
	word-wrap: break-word;
	position: relative;
}



.received .message {
	background: #fff;
}

.message-time {
	font-size: 13px;
	color: #555;
	margin-top: 2px;
	align-self: flex-end;
	white-space: nowrap;
}

.message-row.received .message-time {
	align-self: flex-start;
}

.care-request {
	padding: 0;
}

.care-request-card {
	border-radius:20px;
	background-color:#fff3b0;
    font-size: 16px;
    line-height: 1.4;
    padding : 15px 10px;
}

.card-header {
    display: flex;
    align-items: center;
    padding-bottom: 8px;
    margin-bottom: 10px;
    border-bottom: 1px solid #eeeeee; /* 구분선 */
}

.header-icon {
    font-size: 1.2em;
    margin-right: 6px;
}

.header-title {
    font-weight: 700;
    font-size: 1.1em;
    color: #333333;
}

.detail-row {
    display: flex;
    margin-bottom: 6px; /* 줄 간격 */
    align-items: flex-start;
}

.detail-icon {
    color: #888; /* 아이콘 색상 */
    margin-right: 8px;
    padding-top: 2px;
}

.label {
    font-weight: 600;
    color: #555;
    display: inline-block;
    min-width: 40px; /* 라벨 너비 고정으로 정렬 맞춤 */
}

/* -----------------------------------
   3. Footer 및 상태/버튼 스타일
   ----------------------------------- */
.card-footer {
    display: flex;
    justify-content: space-between; /* 상태 표시와 버튼을 양 끝으로 분리 */
    align-items: center;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid #555;
    
}

/* 상태 표시 뱃지 스타일 */
.care-status {
    display: inline-block;
    padding: 3px 8px;
    border-radius: 12px; /* 둥근 뱃지 모양 */
    font-weight: 600 !important;
    font-size: 18px !important;
    white-space: nowrap;
}

/* 확정 상태 */
.care-status[style*="green"] { 
   /*  background-color: #e6f7e6; */
    color: #38761d !important; 
}

/* 취소 상태 */
.care-status[style*="red"] { 
    /* background-color: #fceceb; */
    color: #cc0000 !important;
}

/* 버튼 스타일 (확정 버튼) */
.confirm-btn {
    background-color: #4c8cff; /* 깔끔한 파란색 */
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 999px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9em;
    transition: background-color 0.2s;
}

.confirm-btn:hover {
    background-color: #3a75e0;
}

.care-confirmed {
	background: #8FBC8F;
	padding: 6px 10px;
	border-radius: 12px;
	margin-top: 4px;
}

.btn-darkbrown {
	font-size : 16px;
	font-family: 'Juache', sans-serif;
	padding: 6px 16px;
	border-radius: 999px;
	border: none;  
    color: white; 
    background-color: #9a7f5a;
    transition: all 0.3s ease;
    cursor : pointer;
}

.btn-darkbrown:hover {
    background-color: #524538;
	color: #fff;  
	border: none;  
}

#input-area {
	display: flex;
	padding: 10px;
	border-top: 1px solid #ddd;
	gap: 10px;
}

#message-input {
	flex-grow: 1;
	padding: 8px;
	border-radius: 20px;
	border: 1px solid #ccc;
	outline: none;
}

/* 버튼에도 폰트, 커서 포인터 적용 */
 #send-button{
 	font-family: 'Juache', sans-serif;
	background-color: #D2B48C;
	color: #fff;
	border-radius: 20px;
	padding: 6px 16px;
	border: none;
	font-weight: 500;
    cursor: pointer; /* 커서 포인터 추가 */
} 


#send-button:hover{
	background-color: #a38b6a; /* hover 시 조금 진하게 */
	color: #fff;
} 

/* ---------------------------------------------------------------------------------- */
/* 2. 돌봄 요청 폼 (CARE FORM) 스타일: 디자인 개선 및 라운드 값 적용 */
/* ---------------------------------------------------------------------------------- */

#care-form {
    display: none; /* 기본은 숨김 */
    padding: 18px; 
    border: 1px solid #e0e0e0; 
    border-radius: 12px; 
    margin: 10px; 
    background-color: #f7f9fb; /* 배경 박스 */
    flex-wrap: wrap; 
    gap: 10px; 
    flex-direction: row; 
    font-size: 16px; 
    line-height: 1.4;
    border-top: 1px solid #ddd; 
}

/* JS로 .active 클래스가 붙으면 폼이 보입니다. */
#care-form.active {
    display: flex;
}

/* 개별 입력 그룹 스타일 */
.care-form-group {
    flex: 1 1 calc(50% - 5px); 
    display: flex;
    flex-direction: column; 
}

/* 메모, 버튼 등 전체 너비 요소 */
.care-form-group.full-width {
    flex: 1 1 100%; 
}

/* 라벨 스타일 */
#care-form label {
    font-weight: bold;
    color: #555;
    margin-bottom: 3px;
}


/* 입력 필드 (input, textarea) 공통 스타일 - 라운드 값 적용 */
#care-form input[type="datetime-local"],
#care-form textarea {
    padding: 10px; 
    border: 1px solid #ccc;
    border-radius: 6px; 
    box-sizing: border-box; 
    margin-top: 4px; 
    width: 100%; 
    font-size: 16px;
    background-color: white; 
}

/* 메모장 줄 수 설정 */
#care-form textarea {
    resize: vertical; 
}

/* 예약 전송 버튼 스타일 */
#confirm-care {
	font-family: 'Juache', sans-serif;
	font-size :20px;
    width: 100%; 
    padding: 10px; 
    border: none;
    border-radius: 20px; 
    font-weight: bold;
    cursor: pointer; /* 커서 포인터 유지 */
    background-color: #D2B48C;
    color: #fff;
    transition: background-color 0.3s;
}

#confirm-care:hover {
	background-color: #a38b6a;
}

/* 버튼 컨테이너 정렬 */
.button-container {
    display: flex;
    justify-content: flex-start;
}

/* ---------------------------------------------------------------------------------- */
/* 3. 리뷰 팝업 스타일 */
/* ---------------------------------------------------------------------------------- */
#review-popup {
	position: absolute;
	top: 0;
	right: 0;
	width: 350px;
	height: 100%;
	background: white;
	box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
	z-index: 100;
	transform: translateX(100%);
	transition: transform 0.3s ease-in-out;
	display: flex;
	flex-direction: column;
	padding: 15px;
	box-sizing: border-box;
	border-left: 1px solid #ddd;
	overflow-y: auto;
}

#review-popup.show {
	transform: translateX(0);
}

.popup-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 15px;
}

.popup-header button {
	background: none;
	border: none;
	font-size: 20px;
	cursor: pointer;
}

#review-rating-summary {
	text-align: center;
	padding: 10px 0;
	border-bottom: 1px solid #eee;
	margin-bottom: 15px;
}

#review-rating-summary h3 {
	margin: 0;
	font-size: 1.5em;
}

#review-rating-summary p {
	margin: 5px 0 0;
	color: #666;
}

.star-rating {
	color: black;
	font-size: 1.2em;
}

/* [수정] 리뷰 등록 폼 스타일 - 배경 박스 추가 */
#review-form-area {
    padding: 15px; 
    margin-bottom: 20px; 
    background-color: #f7f9fb; /* 연한 회색 배경 */
    border-radius: 12px; /* 둥근 모서리 */
    border-top: none; /* 기존 border-top 제거 */
}

#review-form-area h4 {
	font-family: 'Juache', sans-serif;
	font-size:20px;
	margin-top: 0;
	margin-bottom: 15px; /* 제목 아래 간격 추가 */
}

#review-form-area textarea {
	/* [수정] 입력 필드 라운드 값 적용 */
	border-radius: 6px; 
	width: 100%;
	margin-bottom: 10px;
	box-sizing: border-box;
	font-family: 'Juache', sans-serif; /* 명시적으로 폰트 적용 */
}

.rating-input {
	margin-bottom: 10px;
}

.rating-input span {
	font-size: 1.5em;
	cursor: pointer;
	color: #ccc;
}

.rating-input span.active {
	color: gold;
}

#submit-review-btn {
	width: 100%;
	padding: 10px; /* 버튼 높이 증가 */
	background: #D2B48C; 
	color: white;
	border: none;
	border-radius: 20px; 
	cursor: pointer; /* 커서 포인터 추가 */
	font-weight: 500;
	font-family: 'Juache', sans-serif; 
	transition: background-color 0.3s;
}

#submit-review-btn:hover {
	background: #a38b6a;
}

/* 리뷰 목록 스타일 */
#review-list {
	font-size:20px;
	flex-grow: 1;
	overflow-y: auto;
	padding-right: 5px;
}

.review-item {
	/* 리뷰 내용에도 폰트 적용 */
	font-family: 'Juache', sans-serif;
	font-size:18px;
	padding: 10px 0;
	border-bottom: 1px dotted #ddd;
	position: relative;
}
/* 리뷰 내용 래퍼는 항상 표시 (내용 유지 요청에 따라) */
.review-content-wrapper {
	display: block;
}

.review-item:last-child {
	border-bottom: none;
}

.review-header {
	display: flex;
	justify-content: space-between;
	color: #444;
	margin-bottom: 5px;
}

.review-body {
	font-size: 0.95em;
	color: #333;
	word-break: break-all;
}

.review-date {
	font-size: 0.8em;
	color: #999;
	margin-top: 5px;
	display: flex;
	justify-content: space-between;
	align-items: center;
}

/* 
.review-actions button {
	font-size: 0.75em;
	padding: 3px 6px;
	margin-left: 5px;
	border: 1px solid #ccc;
	border-radius: 999px;
	cursor: pointer; 
	background: #fff;
	font-family: 'Juache', sans-serif;
}
 
*/

/* .review-actions button.edit {
	color: #007bff;
	border-color: #007bff;
}

.review-actions button.delete {
	color: #dc3545;
	border-color: #dc3545;
} */

/* ---------------------------------------------------------------------------------- */
/* 4. 인라인 리뷰 수정 폼 스타일 (이미지 레이아웃에 맞게 조정) */
/* ---------------------------------------------------------------------------------- */
.edit-inline-form {
	padding: 10px 0 0 0;
	margin-top: 0px;
	margin-bottom: 5px;
	width: 100%;
	box-sizing: border-box;
	display: none; /* 기본적으로 숨김 처리 */
	font-family: 'Juache', sans-serif;
}
/* 수정 폼 내부의 경계선 스타일 */
.edit-inline-form>div {
	margin-top: 10px;
	padding-top: 10px;
	border-top: 1px dashed #ccc;
}

.edit-inline-form h4 {
	margin: 5px 0 5px 0;
	font-size: 0.9em;
}

.edit-review-textarea {
	/* [수정] 입력 필드 라운드 값 적용 */
	border-radius: 6px; 
	width: 100%;
	box-sizing: border-box;
	margin-bottom: 10px;
	border: 1px solid #ccc; /* 테두리 추가 */
	padding: 5px;
	font-family: 'Juache', sans-serif;
}

.edit-inline-rating {
	margin-bottom: 5px;
}

.edit-inline-rating span {
	font-size: 1.5em;
	cursor: pointer;
	color: #ccc;
}

.edit-inline-rating span.active {
	color: gold;
}

.edit-actions button {
	font-size: 0.8em !important;
	padding: 5px 10px !important;
	font-family: 'Juache', sans-serif !important;
    cursor: pointer !important; /* 커서 포인터 추가 */
}

.edit-actions button.save {
	/* [수정] 색상 통일 */
	background: #D2B48C; 
	color: white;
	border: none;
	border-radius: 4px;
}
.edit-actions button.save:hover {
	background: #a38b6a;
}


.edit-actions button.cancel {
	background: #dc3545;
	color: white;
	border: none;
	border-radius: 4px;
	margin-left: 5px;
}


.btn-outline-danger {
	font-family: 'Juache', sans-serif;
	font-size : 14px;
    border-radius:999px;
    background-color: transparent;
    color: #dc3545;
    border: 2px solid #dc3545;
    transition: all 0.3s ease;
    padding: 6px 8px;
     cursor: pointer;
} 

.btn-outline-danger:hover {
	
    color: white; 
    background-color: #dc3545; 
    border-color: #dc3545;
}


.btn-outline-brown {
	font-family: 'Juache', sans-serif;
	font-size : 14px;
	border: 2px solid #8B4513;
	border-radius:999px;
    color: #8B4513; /* 글자색: 새들 브라운 */
    border-color: #8B4513; /* 테두리색 */
    background-color: transparent; /* 배경 투명 */
    cursor: pointer;
    padding: 6px 8px;
    transition: all 0.3s ease; /* 부드러운 전환 효과 */
}

.btn-outline-brown:hover {
    color: white;
    background-color: #8B4513;
    
}

</style>

<script
	src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
<script
	src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>


	<div id="chat-container">
		<div id="message-area"></div>
		<div id="input-area">
			<input type="text" id="message-input" placeholder="메시지를 입력하세요...">
			<button id="send-button" class="btn btn-fatcat" style="font-size:16px;" >전송</button>
			<button id="care-toggle" class="btn btn-darkbrown" style="font-size:16px;">돌봄 예약</button>
		</div>
        
		<div id="care-form">
			<div class="care-form-group">
				<label for="start-date">시작일:</label>
				<input type="datetime-local" id="start-date">
			</div>
			<div class="care-form-group">
				<label for="end-date">종료일:</label>
				<input type="datetime-local" id="end-date">
			</div>
			
			<div class="care-form-group" style="display: none;">
				<input type="hidden" id="session-status" name="sessionStatus" value="REQUESTED">
			</div>
			
			<div class="care-form-group full-width">
				<label for="session-note">메모:</label>
				<textarea id="session-note" rows="3" placeholder="메모를 입력하세요"></textarea>
			</div>
			<div class="care-form-group full-width button-container">
				<button id="confirm-care" class="btn btn-fatcat">예약 전송</button>
			</div>
		</div>
		<div id="review-popup">
			<div class="popup-header">
				<h2 id="review-target-name"></h2>
				<button onclick="closeReviewPopup()">×</button>
			</div>

			<div id="review-rating-summary">
				<h3 id="avg-rating"></h3>
				<p id="total-reviews"></p>
			</div>

			<div id="review-form-area">
				<h4>리뷰 등록</h4>
				<div class="rating-input" id="new-rating">
					<span data-rating="1">★</span> <span data-rating="2">★</span> <span
						data-rating="3">★</span> <span data-rating="4">★</span> <span
						data-rating="5">★</span>
				</div>
				<textarea id="new-review-text" rows="3" placeholder="리뷰 내용을 입력하세요."></textarea>
				<button id="submit-review-btn" style="font-size : 16px;">리뷰 작성</button>
			</div>
			<hr style="width:100%;height:1px;border:none;background-color:#cccccc;">
			<h4 style="font-size : 20px;">등록된 리뷰</h4>
			<div id="review-list"></div>
		</div>
	</div>
<script>
let senderId = null;
let receiverId = null;
let chatRoomId = null;
let stompClient = null;
let targetUserSeqForReview = null; 
let currentRating = 0; 

let userNames = {}; 

// ✨ 날짜 구분선 로직을 위한 전역 변수 추가 ✨
let lastDisplayedDate = null; 

const messageArea = document.getElementById('message-area');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const careToggle = document.getElementById('care-toggle');
const careForm = document.getElementById('care-form');
const startDateInput = document.getElementById('start-date');
const endDateInput = document.getElementById('end-date');
const confirmCare = document.getElementById('confirm-care');


//--------------------------------------------------------
//사용자 닉네임 조회 로직 추가
//--------------------------------------------------------
async function fetchUserNames(userSeq) {
 try {
     // ⭐ 서버의 사용자 닉네임 조회 API 경로로 변경해야 합니다.
     // 예를 들어, '/api/users/{userSeq}/nickname'과 같은 경로를 가정합니다.
     const res = await fetch(`/api/users/${userSeq}/userName`);
     if (res.ok) {
         const data = await res.json();
         // 서버 응답 구조에 따라 'data.nickname' 또는 'data.userName' 등으로 수정하세요.
         return data.userName; 
     } else {
         console.error(`Error fetching userName for user ${userSeq}:`, res.status);
         return `User ${userSeq}`; // 실패 시 기본값
     }
 } catch (error) {
     console.error(`Network error fetching userName for user ${userSeq}:`, error);
     return `User ${userSeq}`;
 }
}


// --------------------------------------------------------
// 초기화 및 이벤트 리스너
// --------------------------------------------------------

window.onload = function() {
  
    // 💡 [수정] URL에서 senderSeq와 receiverSeq를 가져와 ID 설정
    const urlParams = new URLSearchParams(window.location.search);
    // URL에 파라미터가 없으면 임시로 1과 11을 기본값으로 사용하거나, null 처리합니다.
    senderId = parseInt(urlParams.get('senderSeq')) || null; 
    receiverId = parseInt(urlParams.get('receiverSeq')) || null;

    // 💡 [수정] userNames 초기화 (채팅 표시를 위해 필요)
    userNames[senderId] = '나'; 
    userNames[receiverId] = '상대방'; 
    

    // ID 유효성 검사 및 채팅 초기화
    if (senderId && receiverId && senderId !== receiverId) {
        // UI에 표시 (이전 단계에서 추가된 #sender-info, #receiver-info가 있다면)
        const senderInfo = document.getElementById('sender-info');
        const receiverInfo = document.getElementById('receiver-info');
        if (senderInfo) senderInfo.textContent = userNames[senderId];
        if (receiverInfo) receiverInfo.textContent = userNames[receiverId];

        initChatRoom(); // ID가 설정되면 바로 채팅방 초기화 시작
    } else if (senderId === receiverId && senderId !== null) {
        alert("자기 자신과는 채팅을 할 수 없습니다.");
    } else {
        // URL 파라미터가 누락된 경우
        // alert("채팅에 필요한 사용자 ID가 설정되지 않았습니다. (URL: senderSeq, receiverSeq 확인 필요)");
        console.warn("채팅 ID가 URL에 없어 초기화되지 않았습니다. 테스트를 위해 임시 ID를 사용합니다.");
    }


    sendButton.addEventListener('click', sendMessage);
    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') sendMessage();
    });

    // 돌봄 예약 토글 로직
    careToggle.addEventListener('click', () => {
    	 
    	        careForm.classList.toggle('active');
    	        
    	        if (careForm.classList.contains('active')) {
    	            careToggle.textContent = '예약 취소';
    	        } else {
    	            careToggle.textContent = '돌봄 예약';
    	        }
    });

    confirmCare.addEventListener('click', sendCareRequest);

    document.querySelectorAll('#new-rating span').forEach(star => {
        star.addEventListener('click', () => {
            currentRating = parseInt(star.dataset.rating);
            updateStarRating(currentRating, document.getElementById('new-rating'));
        });
    });

    document.getElementById('submit-review-btn').addEventListener('click', submitReview);
};
// --------------------------------------------------------
// 채팅 및 돌봄 요청 로직 
// --------------------------------------------------------

function sendCareRequest() {
    const start = startDateInput.value;
    const end = endDateInput.value;
    if (!start || !end) return console.error("날짜를 선택하세요."); 
    
    const startIsoFormat = start.replace(' ', 'T');
    const endIsoFormat = end.replace(' ', 'T');
    
    // 초(':00')를 추가하여 백엔드 포맷(yyyy-MM-dd'T'HH:mm:ss)을 완성합니다.
    const startWithSeconds = startIsoFormat + ':00';
    const endWithSeconds = endIsoFormat + ':00';
    
    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: receiverId,
        type: "CARE_REQUEST",
        startDate: startWithSeconds,
        endDate: endWithSeconds,
        status: 'REQUESTED',
        note: document.getElementById('session-note').value,
        content: `돌봄 요청: ${start} ~ ${end}`
    };

    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));

    // 클래스 토글을 사용하도록 변경 (폼을 닫음)
    careForm.classList.remove('active');
    careToggle.textContent = '돌봄 예약';
    
    startDateInput.value = '';
    endDateInput.value = '';
    document.getElementById('session-note').value = '';
}

function confirmCareRequest(sessionId, senderIdFromMsg) {
    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: senderIdFromMsg,
        type: "CARE_CONFIRM",
        sessionId: sessionId,
        content: `✅ 돌봄 예약이 확정되었습니다.`
    };
    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));
}

function updateCareRequestUI(sessionId, confirmedTime) {
    const requestElements = document.querySelectorAll(`[data-session-id="${sessionId}"]`);
    
    const confirmedDate = new Date(confirmedTime.replace(' ', 'T'));
    const formattedDate = `${confirmedDate.getFullYear()}-${(confirmedDate.getMonth() + 1).toString().padStart(2, '0')}-${confirmedDate.getDate().toString().padStart(2, '0')}`;
    const hours = confirmedDate.getHours();
    const minutes = confirmedDate.getMinutes().toString().padStart(2,'0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const hour12 = hours % 12 === 0 ? 12 : hours % 12;
    const formattedTime = `${formattedDate} ${ampm} ${hour12}:${minutes}`;

    requestElements.forEach(element => {
        const confirmButton = element.querySelector('.confirm-btn');
        if (confirmButton) {
            confirmButton.remove();
        }
        
        const existingStatusSpan = element.querySelector('.care-status');
        if (existingStatusSpan) {
            existingStatusSpan.innerHTML = `[✅ 확정됨 - ${formattedTime}]`;
        } else {
            const confirmedSpan = document.createElement('span');
            confirmedSpan.classList.add('care-status'); 
            confirmedSpan.style.color = 'green';
            confirmedSpan.style.fontWeight = 'bold';
            confirmedSpan.innerText = `[✅ 확정됨 - ${formattedTime}]`;
            element.querySelector('.care-request').appendChild(confirmedSpan);
        }
    });
}

async function initChatRoom() {
    if (!senderId || !receiverId) return;
    if (stompClient && stompClient.connected) stompClient.disconnect();

    try {
    	
    			// 💡 [수정] 상대방 닉네임을 먼저 가져옵니다.
        const receiverName = await fetchUserNames(receiverId);
    			
     // userNames 객체를 실제 닉네임으로 업데이트
        userNames[senderId] = '나'; 
        userNames[receiverId] = receiverName; // ⭐ 상대방의 실제 닉네임으로 설정
    			
        const res = await fetch(`/api/chat/room?sender=${senderId}&receiver=${receiverId}`);
        const data = await res.json();
        chatRoomId = data.chatSeq;

        const histRes = await fetch(`/api/chat/history?roomId=${chatRoomId}`);
        const history = await histRes.json();
        
        // ✨ 날짜 구분선 초기화 로직 추가 ✨
        lastDisplayedDate = null; 
        
        displayChatHistory(history);

        connectWebSocket();
    } catch (error) {
        console.error("채팅방 초기화 오류:", error);
    }
}

function connectWebSocket() {
    const socket = new SockJS('/ws');
    stompClient = Stomp.over(socket);

    stompClient.connect({}, () => {
        stompClient.subscribe(`/topic/chat/${chatRoomId}`, (message) => {
            const chatMessage = JSON.parse(message.body);
            displayMessage(chatMessage);
            
            if (chatMessage.type === "CARE_CONFIRM") {
                updateCareRequestUI(chatMessage.sessionId, chatMessage.confirmedTime);
            }
        });
    }, (error) => console.error("Connection error: ", error));
}

function sendMessage() {
    if (!stompClient || !stompClient.connected) return;
    if (!messageInput.value.trim()) return;

    const chatMessage = {
        chatRoomId: chatRoomId,
        senderId: senderId,
        receiverId: receiverId,
        type: "CHAT",
        content: messageInput.value.trim()
    };

    stompClient.send("/app/private-chat", {}, JSON.stringify(chatMessage));
    messageInput.value = '';
}

// --------------------------------------------------------
// 메시지 표시 
// --------------------------------------------------------

// ✨ 날짜를 'YYYY년 M월 D일' 형식으로 포맷하는 함수 (구분선용) ✨
function formatDateForSeparator(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString.replace(' ', 'T'));
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    return `${year}년 ${month}월 ${day}일`; 
}

// ✨ 날짜 비교를 위한 'YYYY-MM-DD' 형식 함수 (비교용) ✨
function getDateString(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString.replace(' ', 'T'));
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
}


/**
 * ISO 형식의 날짜 문자열(예: YYYY-MM-DDTHH:mm:ss)을 
 * 한국어 로케일로 포맷팅합니다.
 */
function formatDateTime(dateString) {
    // 값이 null, undefined, 또는 빈 문자열일 경우 처리
    if (!dateString) {
        return '날짜 정보 없음'; 
    }
    
    // 백엔드에서 YYYY-MM-DDTHH:mm:ss 형식으로 오기 때문에 
    // 문자열을 그대로 사용하여 Date 객체를 생성합니다.
    const date = new Date(dateString);

    // Date 객체 유효성 검사
    if (isNaN(date.getTime())) { // getTime()으로 Invalid Date 체크를 더 확실하게 합니다.
        // DTO 필드가 String 타입이지만, 서버에서 데이터가 깨져서 올 경우 대비
        console.error("날짜 파싱 오류 발생. 원본 문자열:", dateString);
        return '날짜 형식 오류'; 
    }

    // 한국어 로케일과 옵션을 사용하여 포맷팅
    const options = {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true, // 오전/오후 사용
        timeZone: 'Asia/Seoul' 
    };

    // 결과: "2025. 09. 28. 오후 07:25"
    return date.toLocaleString('ko-KR', options);
}

function displayMessage(chatMessage) {
    // ✨ 날짜 구분선 로직 추가 시작 ✨
    const currentMessageDateTimeStr = chatMessage.timestamp || new Date().toISOString().replace('T', ' ').substring(0, 19);
    
    // 현재 메시지의 날짜 (YYYY-MM-DD)
    const currentMessageDate = getDateString(currentMessageDateTimeStr); 
    
    if (currentMessageDate !== lastDisplayedDate) {
        // 날짜가 바뀌었으면 구분선 추가
        const separatorDiv = document.createElement('div');
        separatorDiv.classList.add('date-separator');
        
        const dateSpan = document.createElement('span');
        // 'YYYY년 M월 D일' 형식으로 표시
        dateSpan.textContent = formatDateForSeparator(currentMessageDateTimeStr); 
        
        separatorDiv.appendChild(dateSpan);
        messageArea.appendChild(separatorDiv);
        
        // 마지막 날짜 업데이트
        lastDisplayedDate = currentMessageDate;
    }
    // ✨ 날짜 구분선 로직 추가 끝 ✨
    
    const isSent = chatMessage.senderId === senderId;
    const senderIdForPopup = chatMessage.senderId; 

    const senderName = userNames[chatMessage.senderId] || `User ${chatMessage.senderId}`;
    
    const messageRow = document.createElement('div');
    messageRow.classList.add('message-row');
    messageRow.classList.add(isSent ? 'sent' : 'received');
    
    const timeToFormat = chatMessage.timestamp ? new Date(chatMessage.timestamp.replace(' ', 'T')) : new Date();
    const hours = timeToFormat.getHours();
    const minutes = timeToFormat.getMinutes().toString().padStart(2,'0');
    const ampm = hours >= 12 ? '오후' : '오전';
    const hour12 = hours % 12 === 0 ? 12 : hours % 12;
    const timeString = `${ampm} ${hour12}:${minutes}`;
    
    if (!isSent) {
        // 받은 메시지
        
        // ⭐ [수정] div 대신 img 태그를 사용하고, URL은 receiverProfileImage를 사용합니다. ⭐
        const profileImage = document.createElement('img');
        profileImage.className = 'profile-image'; // ⭐ 아래 CSS에 추가할 클래스 이름
        profileImage.alt = senderName + ' 프로필'; // 상대방의 닉네임을 alt 텍스트로 사용
        
       
        profileImage.src = chatMessage.senderProfileImage || '/images/no_image.jpg'; 


        // -------------------------------------------------
        // ⭐ 프로필 이미지 클릭 시 리뷰 팝업 로직 (유지) ⭐
        // -------------------------------------------------
        profileImage.onclick = (e) => {
            e.stopPropagation();
            openReviewPopup(senderIdForPopup, senderName); // openReviewPopup은 senderId를 사용합니다.
        };
        
        messageRow.appendChild(profileImage); // 수정된 img 태그를 추가합니다.
    }

    const contentWrapper = document.createElement('div');
    contentWrapper.classList.add('message-content-wrapper');

    if (!isSent) {
        const nameDiv = document.createElement('div');
        nameDiv.classList.add('user-nickname'); 
        nameDiv.innerText = senderName; 
        nameDiv.addEventListener('click', () => openReviewPopup(senderIdForPopup));
        contentWrapper.appendChild(nameDiv);
    }

    const messageDiv = document.createElement('div');
    messageDiv.classList.add('message');
    messageDiv.classList.add('tail'); // 꼬리 스타일을 적용합니다.

    if (chatMessage.type === "CARE_REQUEST") {
    	
   	 	console.log("DEBUG: CARE_REQUEST chatMessage Object:", chatMessage);
        console.log("DEBUG: Start Date Value:", chatMessage.startDate, "End Date Value:", chatMessage.endDate);
    	
    		const formattedStartDate = formatDateTime(chatMessage.startDate);
        const formattedEndDate = formatDateTime(chatMessage.endDate);
        const careDiv = document.createElement('div');
        careDiv.setAttribute('data-session-id', chatMessage.sessionId || -1); 
        careDiv.classList.add('care-request');

        const status = chatMessage.status || 'REQUESTED';
        const sessionId = chatMessage.sessionId || -1;
        const isReceiver = chatMessage.senderId !== senderId;

        let confirmButtonHtml = '';
        let statusDisplay = '';

        if (status === 'REQUESTED' && isReceiver) {
            confirmButtonHtml = `<button class="confirm-btn" data-session-id="${sessionId}" data-sender-id="${chatMessage.senderId}">확정</button>`;
        } else if (status === 'CONFIRMED') {
            const formattedConfirmTime = chatMessage.confirmedTime ? 
                formatDateTime(chatMessage.confirmedTime) : 
                '시간 정보 없음';
            statusDisplay = `<span class="care-status" style="color: green; font-weight: bold; font-size:20px;">[✅ 확정됨 - ${formattedConfirmTime}]</span>`;
        } else if (status === 'CANCELLED') {
            statusDisplay = `<span class="care-status" style="color: red; font-weight: bold; font-size:20px;">[❌ 취소됨]</span>`;
        }
        
        


        careDiv.innerHTML =  `
            <div class="care-request-card" style="font-size:16px;">
            <div class="card-header">
                <span class="header-icon">📌</span>
                <span class="header-title">돌봄 요청 상세</span>
            </div>
            
            <div class="card-body" style="font-size:16px;">
                <div class="detail-row time-detail">
                    <span class="detail-icon">📅</span>
                    <div class="detail-text">
                        <span class="label">시작:</span> ${formattedStartDate} 
                    </div>
                </div>
                <div class="detail-row time-detail">
                    <span class="detail-icon">🗓️</span>
                    <div class="detail-text">
                        <span class="label">종료:</span> ${formattedEndDate} 
                    </div>
                </div>
                <div class="detail-row memo-detail">
                    <span class="detail-icon">📝</span>
                    <div class="detail-text">
                        <span class="label">메모:</span> ${chatMessage.note || '없음'}
                    </div>
                </div>
            </div>

            <div class="card-footer">
                ${statusDisplay ? `<div class="status-box">${statusDisplay}</div>` : ''}
                ${confirmButtonHtml ? `<div class="action-box">${confirmButtonHtml}</div>` : ''}
            </div>
        </div>
    `;
        messageDiv.appendChild(careDiv);

        if (status === 'REQUESTED' && isReceiver) {
            const confirmButton = careDiv.querySelector('.confirm-btn');
            if (confirmButton) {
                confirmButton.addEventListener('click', (event) => {
                    const session_Id = parseInt(event.target.dataset.sessionId);
                    const sender_Id = parseInt(event.target.dataset.senderId);
                    if (session_Id !== -1) {
                        confirmCareRequest(session_Id, sender_Id);

                        const tempConfirmedTime = new Date().toISOString().replace('T', ' ').substring(0, 19);
                        updateCareRequestUI(session_Id, tempConfirmedTime);
                    }
                });
            }
        }

    } else if (chatMessage.type === "CARE_CONFIRM") {
        messageDiv.classList.add('care-confirmed');
        messageDiv.innerText = chatMessage.content;
    } else {
        messageDiv.innerText = chatMessage.content;
    }
    
    contentWrapper.appendChild(messageDiv);
    
    const timeDiv = document.createElement('div');
    timeDiv.classList.add('message-time');
    timeDiv.innerText = timeString;
    contentWrapper.appendChild(timeDiv);

    messageRow.appendChild(contentWrapper);

    messageArea.appendChild(messageRow);
    messageArea.scrollTop = messageArea.scrollHeight;
}

function displayChatHistory(history) {
    messageArea.innerHTML = '';
    if (history && Array.isArray(history)) {
        // 메시지 기록은 항상 시간 순서대로 정렬되어 있어야 합니다.
        history.forEach(msg => displayMessage(msg)); 
    }
}


// --------------------------------------------------------
// 리뷰 팝업 및 로직 
// --------------------------------------------------------

function openReviewPopup(targetSeq) {
    if (!targetSeq || targetSeq === senderId) {
        alert("본인에 대한 리뷰는 등록하거나 확인할 수 없습니다.");
        return;
    }
    
    // ⭐ [수정] 다른 리뷰 수정 폼이 열려있다면 닫기
    const activeForm = document.querySelector('.edit-inline-form[data-is-editing="true"]');
    if (activeForm) {
        const activeReviewId = parseInt(activeForm.dataset.reviewId);
        cancelEdit(activeReviewId);
    }


    targetUserSeqForReview = targetSeq;
    const targetName = userNames[targetSeq] || `User ${targetSeq}`;

    document.getElementById('review-target-name').innerText = `${targetName} 님 리뷰`;
    document.getElementById('review-popup').classList.add('show');

    fetchReviews(targetSeq);
}

function closeReviewPopup() {
    document.getElementById('review-popup').classList.remove('show');
    targetUserSeqForReview = null;
    
    currentRating = 0;
    document.getElementById('new-review-text').value = '';
    updateStarRating(0, document.getElementById('new-rating'));

    // ⭐ [수정] 팝업 닫을 때 열려있는 수정 폼이 있다면 닫기
    const activeForm = document.querySelector('.edit-inline-form[data-is-editing="true"]');
    if (activeForm) {
        const activeReviewId = parseInt(activeForm.dataset.reviewId);
        cancelEdit(activeReviewId);
    }
}

async function fetchReviews(targetSeq) {
    const listArea = document.getElementById('review-list');
    const avgRatingElem = document.getElementById('avg-rating');
    const totalReviewsElem = document.getElementById('total-reviews');
    listArea.innerHTML = '불러오는 중...';

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch(`/api/care-reviews?targetUserSeq=${targetSeq}`);
        if (!response.ok) throw new Error('Failed to fetch reviews');
        
        const reviews = await response.json();
        listArea.innerHTML = '';
        
        let totalRating = 0;
        
        if (reviews.length === 0) {
            listArea.innerHTML = '<p style="text-align: center; color: #999;">등록된 리뷰가 없습니다.</p>';
            avgRatingElem.innerHTML = '평점: <span class="star-rating">0.0</span>';
            totalReviewsElem.innerText = '총 0개의 리뷰';
            return;
        }

        reviews.forEach(review => {
            totalRating += review.careRating;
            listArea.appendChild(createReviewItem(review));
        });

        const average = (totalRating / reviews.length).toFixed(1);
        const starHtml = '★'.repeat(Math.round(average)) + '☆'.repeat(5 - Math.round(average));
        
        avgRatingElem.innerHTML = `평점: <span class="star-rating">${average}</span> <span style="color:gold">${starHtml}</span>`;
        totalReviewsElem.innerText = `총 ${reviews.length}개의 리뷰`;

    } catch (error) {
        console.error("리뷰 로드 오류:", error);
        listArea.innerHTML = '<p style="color: red;">리뷰를 불러오는 중 오류가 발생했습니다.</p>';
        avgRatingElem.innerHTML = '평점: <span class="star-rating">--</span>';
        totalReviewsElem.innerText = '총 --개의 리뷰';
    }
}

/**
 * 리뷰 아이템 DOM 요소를 생성합니다. 
 */
function createReviewItem(review) {
    const item = document.createElement('div');
    item.classList.add('review-item');
    
    const starHtml = '★'.repeat(review.careRating) + '☆'.repeat(5 - review.careRating);
    const date = new Date(review.createDate);
    const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;

    // 현재 로그인된 사용자가 리뷰 작성자인 경우에만 수정/삭제 버튼 표시
    let actionButtons = '';
    let editFormHtml = ''; 
    
    if (review.authorUserSeq === senderId) { 
        actionButtons = `
            <div class="review-actions"> 
                <button class="btn-outline-brown" onclick="editReview(${review.reviewSeq}, this)">수정</button>
                <button class="btn-outline-danger" onclick="deleteReview(${review.reviewSeq})">삭제</button>
            </div>
        `;
        
        // ⭐ 인라인 수정 폼 추가 (기본적으로 숨겨짐)
        editFormHtml = `
            <div class="edit-inline-form" data-review-id="${review.reviewSeq}">
                <div>
                    <h4>별점:</h4>
                    <div class="rating-input edit-inline-rating" data-initial-rating="${review.careRating}">
                        <span data-rating="1">★</span>
                        <span data-rating="2">★</span>
                        <span data-rating="3">★</span>
                        <span data-rating="4">★</span>
                        <span data-rating="5">★</span>
                    </div>
                    <h4>내용:</h4>
                    <textarea class="edit-review-textarea" rows="3">${review.careReview}</textarea>
                    <div class="edit-actions" style="margin-top: 5px; text-align: right;">
                        <button class="btn-outline-brown" onclick="saveEditReview(${review.reviewSeq}, this)">저장</button>
                        <button class="btn-outline-danger" onclick="cancelEdit(${review.reviewSeq}, this)">취소</button>
                    </div>
                </div>
            </div>
        `;
    }


    item.innerHTML = `
        <div class="review-content-wrapper" id="review-content-${review.reviewSeq}">
            <div class="review-header">
                <span>${review.authorNickname}</span>
                <span class="star-rating">${starHtml}</span>
            </div>
            <div class="review-body">${review.careReview}</div>
            <div class="review-date">
                <span>${dateString}</span>
                ${actionButtons}
            </div>
        </div>
        ${editFormHtml}
    `;
    item.id = `review-item-${review.reviewSeq}`;
    
    // ⭐ 초기 별점 UI 설정 및 이벤트 리스너 설정
    if (review.authorUserSeq === senderId) {
        const starContainer = item.querySelector('.edit-inline-rating');
        
        // saveEditReview에서 사용할 현재 평점을 data-current-rating에 저장
        starContainer.setAttribute('data-current-rating', review.careRating); 
        updateStarRating(review.careRating, starContainer); 
        
        starContainer.querySelectorAll('span').forEach(star => {
            star.addEventListener('click', () => {
                const newRating = parseInt(star.dataset.rating);
                // HTML 요소 자체에 현재 평점을 저장하여 saveEditReview에서 사용
                starContainer.setAttribute('data-current-rating', newRating); 
                updateStarRating(newRating, starContainer);
            });
        });
    }

    return item;
}

function updateStarRating(rating, container) {
    container.querySelectorAll('span').forEach(star => {
        if (parseInt(star.dataset.rating) <= rating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
}

async function submitReview() {
    const reviewText = document.getElementById('new-review-text').value.trim();

    if (currentRating === 0) {
        return alert("별점을 선택해주세요.");
    }
    if (reviewText.length < 5) {
        return alert("리뷰 내용을 5자 이상 입력해주세요.");
    }
    if (!targetUserSeqForReview || targetUserSeqForReview === senderId) {
        return alert("리뷰 대상을 확인할 수 없습니다.");
    }
    if (!senderId) {
        return alert("리뷰를 작성할 '보내는 사람'을 선택해주세요. (API 호출에 필요)");
    }

    const requestBody = {
        authorUserSeq: senderId, 
        targetUserSeq: targetUserSeqForReview,
        careReview: reviewText,
        careRating: currentRating,
        targetRole: "provider" 
    };

    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch('/api/care-reviews', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 등록에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 등록되었습니다!");
        
        currentRating = 0;
        document.getElementById('new-review-text').value = '';
        updateStarRating(0, document.getElementById('new-rating'));

        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 등록 오류:", error);
        alert(error.message || "리뷰 등록 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    }
}

/**
 * ⭐ 수정 버튼 클릭 시 인라인 수정 폼을 표시합니다.
 * @param {number} reviewId - 수정할 리뷰 ID
 */
function editReview(reviewId) {
    // 1. 현재 수정 중인 다른 폼이 있는지 확인하고 닫기
    const activeForm = document.querySelector('.edit-inline-form[data-is-editing="true"]');
    if (activeForm && parseInt(activeForm.dataset.reviewId) !== reviewId) {
        const activeReviewId = parseInt(activeForm.dataset.reviewId);
        cancelEdit(activeReviewId);
    }

    const reviewContentWrapper = document.getElementById(`review-content-${reviewId}`);
    const editForm = document.querySelector(`.edit-inline-form[data-review-id="${reviewId}"]`);

    if (reviewContentWrapper && editForm) {
        // 2. 리뷰 내용 숨기고 폼 보이기
        reviewContentWrapper.style.display = 'none';
        editForm.style.display = 'block';
        editForm.setAttribute('data-is-editing', 'true');
        
        // 3. 폼에 포커스 주기
        const textarea = editForm.querySelector('.edit-review-textarea');
        if (textarea) textarea.focus();
        
        // 4. 스크롤 조정 (리뷰 목록의 맨 위로 스크롤하여 수정할 리뷰가 잘 보이도록)
        const reviewList = document.getElementById('review-list');
        const item = document.getElementById(`review-item-${reviewId}`);
        if (reviewList && item) {
             reviewList.scrollTop = item.offsetTop - reviewList.offsetTop - 10; // 10px 여백
        }
    }
}

/**
 * ⭐ 수정 폼을 닫고 원래 리뷰 내용으로 되돌립니다.
 * @param {number} reviewId - 리뷰 ID
 */
function cancelEdit(reviewId) {
    const reviewContentWrapper = document.getElementById(`review-content-${reviewId}`);
    const editForm = document.querySelector(`.edit-inline-form[data-review-id="${reviewId}"]`);
    
    if (reviewContentWrapper && editForm) {
        // 1. 폼 숨기고 리뷰 내용 보이기
        editForm.style.display = 'none';
        editForm.removeAttribute('data-is-editing');
        reviewContentWrapper.style.display = 'block';
        
        // 2. 수정 중이었던 폼의 내용 초기화 (리뷰 내용으로)
        const ratingContainer = editForm.querySelector('.edit-inline-rating');
        const initialRating = parseInt(ratingContainer.dataset.initialRating);
        const initialContent = reviewContentWrapper.querySelector('.review-body').innerText;
        
        editForm.querySelector('.edit-review-textarea').value = initialContent;
        ratingContainer.setAttribute('data-current-rating', initialRating);
        updateStarRating(initialRating, ratingContainer);
    }
}

/**
 * ⭐ 수정된 내용을 저장하고 API를 호출합니다.
 * @param {number} reviewId - 수정할 리뷰 ID
 * @param {HTMLElement} saveButton - 클릭된 저장 버튼 요소
 */
async function saveEditReview(reviewId, saveButton) {
    const editForm = saveButton.closest('.edit-inline-form');
    if (!editForm) return alert("수정 폼을 찾을 수 없습니다.");
    if (!senderId) return alert("'보내는 사람'을 선택해야 수정이 가능합니다. (API 호출에 필요)"); 

    const editedText = editForm.querySelector('.edit-review-textarea').value.trim();
    const ratingContainer = editForm.querySelector('.edit-inline-rating');
    
    // data-current-rating에서 현재 선택된 평점을 가져오고, 없으면 초기 평점을 사용
    const editedRating = parseInt(ratingContainer.getAttribute('data-current-rating') || ratingContainer.dataset.initialRating);

    if (editedRating === 0) {
        return alert("별점을 선택해주세요.");
    }
    if (editedText.length < 5) {
        return alert("리뷰 내용을 5자 이상 입력해주세요.");
    }
    
    // 버튼 비활성화 (중복 클릭 방지)
    saveButton.disabled = true;

    const requestBody = {
        authorUserSeq: senderId, 
        targetUserSeq: targetUserSeqForReview, 
        careReview: editedText,
        careRating: editedRating,
        targetRole: "provider" 
    };

    try {
        const response = await fetch(`/api/care-reviews/${reviewId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 수정에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 수정되었습니다!");
        
        // 폼 닫고 전체 목록 새로고침
        cancelEdit(reviewId); 
        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 수정 오류:", error);
        alert(error.message || "리뷰 수정 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    } finally {
        saveButton.disabled = false; // 버튼 다시 활성화
    }
}


async function deleteReview(reviewId) {
    if (!senderId) return alert("'보내는 사람'을 선택해야 삭제가 가능합니다. (API 호출에 필요)"); 
    if (!confirm("정말로 이 리뷰를 삭제하시겠습니까?")) return;

    // 삭제 전에 혹시 수정 폼이 열려있었다면 닫습니다. (clean up)
    const activeForm = document.querySelector('.edit-inline-form[data-is-editing="true"]');
    if (activeForm && parseInt(activeForm.dataset.reviewId) === reviewId) {
        activeForm.removeAttribute('data-is-editing');
    }
    
    try {
        // 이 API 경로는 사용자의 서버 환경에 맞게 조정되어야 합니다.
        const response = await fetch(`/api/care-reviews/${reviewId}?authorUserSeq=${senderId}`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' }
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: '알 수 없는 오류' }));
            throw new Error(`리뷰 삭제에 실패했습니다. (${errorData.message})`);
        }

        alert("리뷰가 성공적으로 삭제되었습니다!");
        fetchReviews(targetUserSeqForReview); 

    } catch (error) {
        console.error("리뷰 삭제 오류:", error);
        alert(error.message || "리뷰 삭제 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.");
    }
}
</script>
</body>
</html>